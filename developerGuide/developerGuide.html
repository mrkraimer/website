<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS V4 Developer's Guide</title>
  <link rel="stylesheet" type="text/css"
  href="../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>EPICS V4 Developer's Guide</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount">editions</h2>
<dl>
  <dt>2019.04.19</dt>
     <dd>Original</dd>
  <dt>2012.03.29</dt>
     <dd>Update</dd>
</dl>  
<p>
<b>NOTE:</b> This is the working version of the developerGuide.
</p>
<dl>
    <dt>Editors:</dt>
   <dd>
      Marty Kraimer
    </dd>
  </dl>

<h2 class="nocount">Abstract</h2>

<p>
This document is a developer guide for the module components of
<a href="https://epics-controls.org/resources-and-support/base/epics-7/">
EPICS-7
</a>
</p>
</div>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Overview of the PVA components of EPICS 7</h2>
<p>
This document briefly describes a set of application programming interfaces (APIs)
for PVA.</p>
<p>
These core APIs provide a toolkit for creating applications that access and/or provide sources of structured data. This document is intended for EPICS software developers who want to implement applications via the core APIs.
</p>
<p>This document is a tutorial rather then a detailed reference manual.
Links to the reference manual for each PVA modules are provided in the following overview sections.
</p>
<h3>PVA Modules</h3>
<p>
The current release of EPICS 7 includes the following PVA modules:
</p>
<dl>
   <dt>pvData</dt>
      <dd>
       The EPICS PVA type system, which describes and implements structured data.
      </dd>
   <dt>normativeTypes</dt>
      <dd>
        A set of standard <b>pvData</b> structures.
      </dd>
   <dt>pvAccess</dt>
      <dd>
       Support for connecting a client to servers and for transporting <b>pvData</b> between client and server.
      </dd>
   <dt>pvaClient</dt>
      <dd>
       pvAccess is a callback based API.
       pvaClient provides a synchronous interface,
      simpified callback classes, and a number of convenience methods.
      </dd>
   <dt>pvDatabase</dt>
      <dd>
       A memory resident database of PVRecords and a channel provider for accessing the PVRecords.
      </dd>
   <dt>pva2pva</dt>
      <dd>
       This consists of two components: 1) A gateway, and 2) <b>qsrv</b>.
       This document only discusses qsrv.
       <br />
       <b>qsrv</b>
       is a channel provider for EPICS DBRecords.
      </dd>
</dl>
<p>In addition the following, although not part of the current EPICS 7 release,
are based on PVA:
</p>
<dl>
   <dt>example</dt>
       <dd>
       A set of examples that use all of the above components.
       </dd>
    <dt>pvaPy</dt>
       <dd>
       Python wrapper for <b>pvData</b> and pvAccess.
       This is not described in this docmument.
       </dd>
</dl>


<p><b>pva2pva</b> and <b>pvaPy</b> are implemented only in C++.
Each has a single github repository.
</p>
<p>
All the components are implemented in C++.
Some of the components are also implemented in Java, but the Java components are not described here.
</p>
<p>
All components have it's own public repository.
For example <b>pvDataCPP</b> has the repository
<a href="https://github.com/epics-base/pvDataCPP">pvDataCPP</a>
</p>
<h3>Terminology</h3>
<dl>
   <dt>EPICS 7</dt>
     <dd>
      This is a combination of <b>epics-base</b> and what was previously called EPICS V4,
       but is now called <b>PVA</b>.
       <br />
       <b>epics-base</b> is what has existed since about 1990.
         It has had many releases: The oldest set of releases are the 3.11 series
         and the newest is the base_7.* series.
         <b>epics-base</b> is also refered to as <b>EPICS V3</b>.
         It provides support for <b>DBRecord</b>s.
         <br />
         A <b>DBRecord</b> has as a flat data structure,
         with fields determined by the record type.
       <b>PVA</b> adds structured data and works along side <b>EPICS V3</b>.
       It's main components are:
       <dl>
         <dt>pvData</dt>
           <dd>API and implementation for structured data</dd>
         <dt>normativeTypes</dt>
           <dd>A set of structures designed for use by tools like display managers,
            archivers, etc.
           </dd>
         <dt>pvAccess</dt>
            <dd>Network support and API for transfering data between clients and servers.
             All data is handled as <b>pvData</b> objects.
           </dd>
       </dl>
     </dd>
   <dt>API - Application Programming Interface </dt>
     <dd>
      The <b>pvData</b> API is how a client accesses the type system
      and data objects for each type.
      </dd>
   <dt>Introspection API</dt>
      <dd>The type system supports both introspection and data interfaces.
       The introspection interfaces allow a client to determine the data types for objects
       without requiring a data instance.
      </dd>
   <dt>Data API</dt>
     <dd>These provide access to data instances.
     </dd>
     <dt>type</dt>
        <dd>Often used when talking about a field.
          In this case it means the intospection interface for the field.
        </dd>
     <dt>PVScalarType</dt>
       <dd>Generic name for the data type for a scalar.
        Thus a generic name for one of PVBoolean, PVByte, ..., PVString.
        </dd>
     <dt>PVScalarArrayType</dt>
       <dd>Generic name for the data type for a scalarArray.
        This a generic name for one of PVBooleanArray,
         PVByteArray, ..., PVStringArray.
        </dd>
     <dt>PVType</dt>
       <dd>Generic name for any valid Data API type.
        </dd>
     <dt>Special Field</dt>
        <dd>These are a set standard structure definitions:
        <b>enum</b>, <b>alarm</b>, <b>timeStamp</b>, <b>control</b>, <b>display</b>, and <b>alarmLimit</b>.
        </dd>
</dl>
<h3>Overview: pvData</h3>
<p>
pvData supports structured data where a structure is a set of fields.
Each field is composed of one of the following types:
</p>
<dl>
   <dt>scalar</dt>
      <dd>
        The field holds data that has a single scalarType:
        <dl>
            <dt>boolean</dt>
               <dd>Can be <b>true</b> or <b>false</b>.
               </dd>
            <dt>signed Integer</dt>
               <dd>Integers of 8, 16, 32, and 64 bits are supported.</dd>
            <dt>unsigned Integer</dt>
                <dd>Unsigned integers of 8, 16, 32, and 64 bits are supported.</dd>
            <dt>float</dt>
                <dd>IEEE 32 bit floating point.</dd>
            <dt>double</dt>
                <dd>IEEE 64 bit floating point.</dd>
            <dt>string</dt>
                <dd>In C++ std::string and on the network UTF8.</dd>
        </dl>
      </dd>
   <dt>scalarArray</dt>
      <dd>An array of one of the scalar types.</dd>
   <dt>structure</dt>
      <dd>A set of fields and a name for each field.
       Each field can have any valid type but the type can not change.
      </dd>
   <dt>structureArray</dt>
      <dd>
       An array of structures. Each element must have the same introspection interface.
      </dd>
   <dt>union</dt>
      <dd>
        A field that has a single sub field which can dynamically change type.
      A variant union allows any valid type. A restricted union allows for a set of valid types.
      </dd>
   <dt>unionArray</dt>
      <dd>
       A array of unions. Each element must have the same introspection interface.
      </dd>
</dl>
<h3>Overview: normativeTypes</h3>

<p>
Each normative type defines a structure that has a set of standard fields.
For example NTScalar defines:</p>
<pre>
epics:nt/NTScalar:1.0
    double value                        // mandatory and can be any scalar type
    string descriptor                   // optional
    alarm_t alarm                       // optional
        int severity
        int status
        string message
    time_t timeStamp                    // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    display_t display                   // optional
        double limitLow
        double limitHigh
        string description
        string format
        string units
    control_t control                   // optional
        double limitLow
        double limitHigh
        double minStep
    string extra1                       // extra
    string[] extra2                     //
</pre>
<h3>Overview: pvAccess</h3>
<p>
A client written in either Java or C++ can communicate with a server written in either Java or C++.
All communication between client and server is done via the methods provided by pvAccess and by <b>pvData</b> objects.
</p>
<p>
pvAccess provides:</p>
<dl>
   <dt>channelProviderRegistry</dt>
     <dd>An arbitrary number of channelProviders can be created.
       Starting with EPICS 7, a separate registry exists for client and server.
     </dd>
   <dt>channelProvider</dt>
     <dd>Code that provides access to a <b>pvData</b> data source.
      It creates channels.<br />
       A channel:
       <ul>
          <li>Provides access to a <b>pvData</b> structure.</li>
          <li>Has an associated channelName.</li>
       </ul>
     </dd>
   <dt>channel</dt>
      <dd>Methods for each of the following:
        <dl>
           <dt>getField</dt>
              <dd>Get the <b>pvData</b> introspection information.</dd>
           <dt>channelGet</dt>
              <dd>Get data.</dd>
           <dt>channelPut</dt>
               <dd>Put data.</dd>
           <dt>channelPutGet</dt>
               <dd>Put data, let server process, and then get result.</dd>
           <dt>monitor</dt>
               <dd>Monitor <b>pvData</b> changes.</dd>
           <dt>channelArray</dt>
               <dd>get/put subArray data.</dd>
           <dt>channelRPC</dt>
               <dd>Like channelPutGet but on each request pvData
                 interfaces for put and get can change.</dd>
        </dl>
       </dd>
</dl>
<p>
channelPutGet and channelRPC provide the equivalent of a Remote Procedure Call.
The client passes a <b>pvData</b> object to the server.
This <b>pvData</b> object is the argument for the RPC.
The server uses this to decide what to do
and sends a <b>pvData</b> object back to the client, which is the RPC result.
</p>
<h3>Overview: pvaClient</h3>
<p>pvaClient is a synchronous wrapper for the pvAccess API, which is a callback based API.
In addition pvaClient provides many convenience methods.
Thus it is easier to use than pvAccess itself.
</p>
<p>pvaClientCPP also provides simplified callback classes, which can be used to implement
non blocking client code.
pvaClientJava should be upgraded to support the same features.
</p>
<h3>Overview: pvDatabase</h3>
<p>A framework for implementing a network accessible database of smart memory resident
records. Network access is via pvAccess. The data in each record is a top level PVStructure as defined by
pvData. A complete implementation of ChannelProvider,
named <b>local</b>, is provided for accessing the records.
The framework can be extended in order to create record instances that implement services.
The minimum that an extension must provide is a top level PVStructure, a record name, and a process method.
The record name is the channel name for provider <b>local</b>.
</p>

<h3>Overview: pva2pva</h3>

<p><b>qsrv</b> (a major component of pva2pva) is a channel provider for accessing DBRecords in an IOC.
qsrv allows clients to get, put and monitor V3 PVs (fields of EPICS DB records) via pvAccess, translating
the value and its meta data (graphics limits, alarm status, timestamp) to or from V4 Normative Type (NT)
pvData structures (NTScalar, NTScalarArray, and NTEnum).</p>
<h3>Overview: pvaPy</h3>
<p>A Python wrapper for <b>pvData</b> and pvAccess.
This is not discussed in this document.
</p>
<h3>Overview: channelProvider</h3>
<p>The basic requirements for a channel provider are:</p>
<ol>
   <li>Given a channel name, find and connect to the data source</li>
   <li>Implement one or more of the channel methods: getField, createChannelGet, etc.</li>
   <li>get/put all data as pvData.</li>
   <li>Prefer normative types instead of raw pvData</li>
</ol>
<p><b>pvAccess</b> implements <b>channelProviderRegistry</b>, which
allows an arbitrary number of providers.
</p>
<p>
Starting with EPICS 7 there are separate client and server registries.
</p>
<p>
A provider is one of the following:</p>
<dl>
   <dt>Client Provider</dt>
     <dd>Called by code that wants to access a <b>channel</b>, where
       each channel has a unique channel name</dd>
   <dt>Server Provider</dt>
     <dd>A provider for the remote side of the <b>pva</b> provider, which is
       described next.</dd>
</dl>
<p>
Before either kind of provider can be used it must first register itself with the 
<b>channelProviderRegistry</b>
</p>
<h4>Provider pva</h4>
<p>An important component of EPICS V4 is provider <b>pva</b>, which is a provider
that implements a connection between a client and a server that uses the pva network
      protocal as defined in:
         <a
          href="http://epics-pvdata.sourceforge.net/pvAccess_Protocol_Specification.html">
          pvAccess_Protocol_Specification.html</a>
</p>
<p>Provider <b>pva</b> has two components:</p>
<dl>
  <dt>client</dt>
     <dd>This is what a pvAccess client uses.</dd>
  <dt>remote</dt>
     <dd>This connects to server providers</dd>
</dl>
<p>Network communcation is used between client and server.
Remote <b>pva</b> transfers data between the network and channel providers that
have registered at the remote node.</p>
<h4>Client Providers</h4>
<p>An arbitrary number of client providers can be implemented.
Each provider must implement the <b>channel</b> interface
mentioned above and must register with the <b>channelProviderRegistry</b>
before it can be used by a client.
</p>
<p>pvAccess itself provides the following client providers:</p>
<dl>
   <dt>pva</dt>
      <dd>The client side of provider <b>pva</b>.
       </dd>
   <dt>ca</dt>
     <dd>This is a connection that uses channel access to access an epics V3 channel.</dd>
   <dt>pipelineService</dt>
      <dd>
       A pipelineService is a service that provides a lossless channel monitor.
       A client requests access to a pipelineService via a pvRequest argument.<br />
      pvGet and eget provide support.<br />
      Other clients could also access a server that implements a pipelineService.
       </dd>
</dl>
<h4>Server Providers</h4>
<p>At present the following providers are available for the remote side of <b>pva</b></p>
<dl>
   <dt>local</dt>
      <dd>This is implemented by pvDatabase</dd>
   <dt>qsrv</dt>
      <dd>This is a provider that directly accesses <b>DBRecord</b>s.</dd>
   <dt>pipelineService</dt>
      <dd>
        
         pvAccess provides a helper class for a service that wants to implement a  pipelineService.
      </dd>
</dl>
<h4>Client Provider Choices</h4>
<p>At present a client that is not running as part of a V3 IOC or a pvDatabase
has two choices for channelProvider: <b>pva</b> and <b>ca</b>.
A client running as part of a V3 IOC also has the same choices.
</p>
<p>
Since <b>channelProviderRegistry</b> allows an arbitrary number of providers,
additional providers can be developed for either the client or remote side of <b>pva</b>.
</p>
<h2>pvTools</h2>
<p>pvAccessCPP implements the following command line tools: 
pvlist, pvget, pvput, pvinfo, and eget.
</p>
<p>See:
<a
href="./pvTools/pvTools.html">pvTools
</a>
</p>
<p>pvget and pvput support request options. See:
<a
href="./pvRequest/pvRequest.html">pvRequest
</a>
</p>
<h2>example code</h2>
<p>
<b>NOTE:</b>
exampleCPP is not part of the EPICS 7 release.
They must be cloned from github:
</p>
<pre>
git clone https://github.com/epics-base/exampleCPP.git
</pre>

<p><b>exampleCPP</b> has examples that use code from all modules
described in this document except for <b>pvaPy</b>.
In particular it has examples:</p>
<dl>
    <dt>database</dt>
       <dd>
         Example server code implemented via pvDatabase.<br />
         In addition it shows how to have PVRecords and V3 Records both running as part of a V3 IOC.
         <br />
         It also shows how to start provider <b>qsrv</b> so that both <b>ca</b> and <b>pva</b>
         can be used to access the V3 records.
       </dd>
    <dt>exampleClient</dt>
        <dd>
          example client code using the pvaClient API.
       </dd>
    <dt>exampleLink</dt>
        <dd>
        Implements PVRecords that get and put to other records.
        </dd>
</dl>
<p>These examples can be used while learning what is described in this document.
ExampleCPP has other examples.
</p>

<p>Examples in exampleClient require that the database in exampleCPP/database is started.
The exampleDatabase can be started either as a main
program or as part of a V3 IOC.
If started as part of a V3 IOC, it also has V3 records and starts <b>qsrv</b>.
All the V4 PVRecords have the prefix <b>PVR</b> and all the V3 DBRecords have the prefix
<b>DBR</b>.
</p>
<p>
In linux <b>exampleCPP/database</b> can be started as follows:</p>
<pre>
mrk> pwd
/home/epicsv4/master/exampleCPP/database/iocBoot/exampleDatabase
mrk> ../../bin/linux-x86_64/exampleDatabase st.cmd
</pre>
<p>The example database has both V3 IOC records and V4 PVRecords.
In addition <b>qsrv</b> is running. Thus all V3 records are available via either <b>ca</b> or <b>pva</b>.
The PVRecords are only available via <b>pva</b>.
Examples of using ca and pva command line tools are:</p>
<pre>
mrk> pvlist 
GUID 0x7F06B2560000000047B97D25 version 1: tcp@[10.0.0.37:45345, 192.168.124.1:45345]
mrk> pvlist 0x7F06B2560000000047B97D25
DBRao01
DBRdouble00
.... many more records
mrk> pvget PVRlong
PVRlong                        0
mrk> caget PVRlong
Channel connect timed out: 'PVRlong' not found.
mrk> caget DBRdouble01
DBRdouble01                       0
mrk> pvget DBRdouble01
DBRdouble01                       0
mrk> caget PVRushort01
Channel connect timed out: 'PVRushort01' not found.
mrk> pvget PVRushort01
PVRushort01                       0
mrk> 
</pre>
<p>The examples in <b>exampleCPP/exampleClient</b> can now be run.
For example:</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/exampleClient
mrk> ls bin/linux-x86_64/
addRecord                    getField            ntMultiGet
examplePvaClientGet          getputmonitor       ntMultiMonitor
examplePvaClientMonitor      helloWorldPutGet    ntMultiPut
examplePvaClientMultiDouble  helloWorldRPC       process
examplePvaClientNTMulti      monitor             put
examplePvaClientProcess      multiGetDouble      putGet
examplePvaClientPut          multiMonitorDouble  putUnion
get                          multiPutDouble      rpc
mrk> 
mrk> bin/linux-x86_64/examplePvaClientGet
_____examplePvaClientGet starting_______
__exampleDouble__
short way
as double 0
long way
as double 0
... LOTS MORE OUTPUT

</pre>

<h2>pvaClient Tutorial</h2>
<h3>Some Basic Concepts</h3>
<h4>Special Field Structures</h4>
<p><b>EPICS V3 DBD</b> defines data related to the <b>VAL</b> field of a <b>DBRecord</b>
</p>
<p>
The following provide <b>pvData</b> definitions for this data:
<b>alarm</b>, <b>timeStamp</b>, <b>enum</b>, <b>display</b>, <b>control</b>, and <b>alarmLimit</b>.
</p>
<p>
Each is a structure that also has an associated <b>structure id</b> name.
For example <b>alarm_t</b> is the structure id name for an alarm structure.
For the tutorial <b>alarm</b>, <b>timeStamp</b>, and <b>enum</b> are briefly discussed.
Below, in section "Special Fields", there is a fuller description of these and the other definitions.
Also see:
<a
href="./pvRequest/pvRequest.html">pvRequest
</a>
</p>
<dl>
   <dt>alarm</dt>
   <dd>
<pre>
alarm_t alarm
    int severity
    int status
    string message 
</pre>
     <p>
     <b>pvData</b> provides code associated with a alarm structure.
     This code restricts severity to be one of:
     </p>
<pre>
noAlarm,minorAlarm,majorAlarm,invalidAlarm,undefinedAlarm
</pre>
    <p> and status to be one of:</p>
<pre>
noStatus,deviceStatus,driverStatus,recordStatus,
dbStatus,confStatus,undefinedStatus,clientStatus
</pre>      
   </dd>
   <dt>timeStamp</dt>
   <dd>
<pre>
time_t timeStamp
    long secondsPastEpoch
    int nanoseconds
    int userTag
</pre>
     <p>
     <b>pvData</b> provides code associated with a timeStamp structure.
      This code provides support that makes the timeStamp
      UTC (Universial Time Coordinated) compliant.
     </p>
   </dd>
   <dt>enum</dt>
   <dd>
<pre>
enum_t value
    int index
    string[] choices
</pre>
     <p>
     <b>pvData</b> provides code associated with an enum structure.
     This forces the index to select an element of the choices.
     </p>
   </dd>
</dl>
<h4>pvRequest</h4>
<p>Each of the PVChannel create methods has a PVStructure argument named <b>pvRequest</b>.
This structure allows the client to 1) select a subset of the fields in the top level structure
from the server, 2) provide record options, and 3) provide field specific options.
<br />
See:
<a
href="./pvRequest/pvRequest.html">pvRequest
</a>
for a full description.
</p>
<p>
<b>pvAccess</b> provides a method <b>createRequest</b> that, given a string,
creates a <b>pvRequest</b> structure.
</p>
<p>
For this tutorial lets just give a simple example:
</p>
<pre>
"field(value, alarm, timeStamp)"
or just
"value, alarm, timeStamp"
</pre>
Specifies that the client wants to receive the top level fields named <b>value</b>,
<b>alarm</b> , and <b>timeStamp</b>.
<h3>C++ Tutorial</h3>
<p>
The tutorial is not part of an EPICS 7 release.
It can be cloned via the command:
</p>
<pre>
git clone  https://github.com/mrkraimer/pvaClientTutorialCPP.git
cd pvaClientTutorialCPP
make
</pre>
<p>Clone it in the same directory that holds your EPICS 7 release.
Documentation is provided in pvaClientTutorialCPP/documentation/clientTutorialCPP.html.
</p>

<h2>pvAccess Channel Providers.</h2>
<p>
<b>NOTES:</b>
</p>
<dl>
   <dt>pvaClient</dt>
   <dd>
If you are using pvaClientCPP or pvaClientJava to write client code then pvaClient takes care of starting
and destroying client providers.
   </dd>
   <dt>pvDatabase</dt>
    <dd>
If You are using exampleCPP/database as a basis for creating your own 
server then the examples show how to start and destroy the server providers.
exampleCPP/exampleLink shows how to start and destroy both the client and server
providers.
    </dd>
    <dt>pav2pva</dt>
     <dd>This provides support for starting a remote <b>pva</b> server and provider <b>qsrv</b> as part of an IOC.
     </dd>
</dl>
<p>pvAccess implements the following providers:</p>
<dl>
   <dt>pva</dt>
     <dd>This is a provider that trasfers data via the network protocol defined pvAccess.
     <br/>
      This provides the client and server side of the network protocol.
      The client side is a complete implementation.
      The server side requires additional code to access data sources but takes care of all network code.
     </dd>
    <dt>ca</dt>
      <dd>This is client support for transfering data via the EPICS V3 channel access protocol.
      </dd>
</dl>
<p>Providers can be provided for other data sources.
A provider must implement <b>ChannelProvider</b> and <b>Channel</b>.
pvAccess supports an arbitrary number of providers.
On the server side of remote <b>pva</b> providers must be implemented,
because <b>pva</b> calls the providers to implement the <b>Channel</b> methods.
</p>
<p>
At present C++ provides two server side providers:
</p>
<dl>
   <dt>qsrv</dt>
      <dd>This is a pvAccess server that accesses V3 records,</dd>
   <dt>local</dt>
      <dd>This is implemented by pvDatabaseCPP</dd>
</dl>


<h2>pvData: Standard Fields</h2>
<p>The following discusses the following fields:
</p>
<dl>
  <dt>enum</dt>
    <dd>
     V4 replacment for the value field data for bi, bi, mbbi, mbbo, records types.
    </dd>
  <dt>alarm</dt>
    <dd>
     V4 implementation of alarm status and severity.
    </dd>
  <dt>timeStamp</dt>
    <dd>
      V4 implementation of timeStamp.
    </dd>
  <dt>display</dt>
    <dd>
      V4 implementation of display fields.
    </dd>
  <dt>control</dt>
    <dd>
      V4 implementation of control fields.
    </dd>
  <dt>valueAlarm</dt>
    <dd>
      V4 implementation of alarm limits.
    </dd>
</dl>

<h3>enum</h3>
Defined in:
<pre>
pvDataCPP/include/pv/pvEnumerated.h
</pre>
<h4>structure</h4>
<p>An enumerated structure is a structure that has fields:</p>
<pre>
enum_t
    int index
    string[] choices
</pre>
<h4>PVEnumerated</h4>
<pre>
PVEnumerated
    bool attach(PVField pvField)
    void detach()
    boolean isAttached()
    boolean setIndex(int index)
    int getIndex()
    String getChoice()
    boolean choicesMutable()
    String[] getChoices()
    int getNumberChoices()
    bool setChoices(String[] choices)
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      pvField (is not, is) an enumerated structure.</dd>
  <dt>detach</dt>
    <dd>Detaches from the <b>pvData</b> structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an enumerated structure?</dd>
  <dt>setIndex</dt>
    <dd>Set the index field in the <b>pvData</b> structure. An exception is thrown if
      not attached to a <b>pvData</b> structure. </dd>
  <dt>getIndex</dt>
    <dd>Get the index field in the <b>pvData</b> structure. </dd>
  <dt>getChoice</dt>
    <dd>Get the String value corresponding to the current index field in the
      <b>pvData</b> structure. An exception is thrown if not attached to a pvData
      structure. </dd>
  <dt>choicesMutable</dt>
    <dd>Can the choices be changed? Note that this is often true. An exception
      is thrown if not attached to a <b>pvData</b> structure. </dd>
  <dt>getChoices</dt>
    <dd>Get the array of choices. An exception is thrown if not attached to a
      <b>pvData</b> structure. </dd>
  <dt>getNumberChoices</dt>
     <dd>Return the number of choices</dd>
  <dt>getNumberChoices</dt>
    <dd>Get the number of choices. An exception is thrown if not attached to a
      <b>pvData</b> structure. </dd>
  <dt>setChoices</dt>
    <dd>Change the choices. An exception is thrown if not attached to a pvData
      structure. </dd>
</dl>

<h3>alarm</h3>
Defined in:
<pre>
pvDataCPP/include/pv/alarm.h
and
pvDataCPP/include/pv/pvAlarm.h
</pre>
<h4>structure</h4>
<p>An alarm structure is defined as follows:</p>
<pre>
alarm_t alarm
    int severity
    int status
    string message
</pre>
<p>Note that severity and status are NOT defined as enumerated structures.
The reason is performance, i. e. prevent passing the array of choice strings everywhere.
The AlarmStatus and AlarmSeverity provide the equivalent of choices for an
enumerated structure.</p>
<h4>AlarmSeverity</h4>
<p>Alarm Severity defines the possible alarm severities</p>
<pre>
enum AlarmSeverity{
    noAlarm,minorAlarm,majorAlarm,invalidAlarm,undefinedAlarm
}
AlarmSeverityFunc {
    AlarmSeverity getSeverity(int value)
    String[] getSeverityNames()
}
</pre>
where
<dl>
  <dt>getSeverity</dt>
    <dd>Get the alarm severity corresponding to the integer value.</dd>
  <dt>getSeverityNames</dt>
    <dd>Get the array of severity choices.</dd>
</dl>
<h4>AlarmStatus</h4>
<p>Alarm Status defines the possible alarm status conditions</p>
<pre>
enum AlarmStatus {
    noStatus,deviceStatus,driverStatus,recordStatus,
    dbStatus,confStatus,undefinedStatus,clientStatus
}

AlarmStatusFunc{
    getStatus(int value)
    String[] getStatusNames()
</pre>
where
<dl>
  <dt>getStatus</dt>
    <dd>Get the alarm status corresponding to the integer value.</dd>
  <dt>getStatusNames</dt>
    <dd>Get the array of status choices.</dd>
</dl>
<h4>Alarm</h4>
<pre>
Alarm {
    String getMessage()
    void setMessage(String message)
    AlarmSeverity getSeverity()
    void setSeverity(AlarmSeverity alarmSeverity)
    AlarmStatus getStatus()
    void setStatus(AlarmStatus alarmStatus)
}
</pre>
where
<dl>
  <dt>getMessage</dt>
    <dd>Get the message.</dd>
  <dt>setMessage</dt>
    <dd>Set the message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the severity.</dd>
  <dt>setSeverity</dt>
    <dd>Set the severity.</dd>
  <dt>getStatus</dt>
    <dd>Get the status.</dd>
  <dt>setStatus</dt>
    <dd>Set the status.</dd>
</dl>
<h4>PVAlarm</h4>
<pre>
PVAlarm {
    bool attach(PVField pvField)
    void detach()
    boolean isAttached()
    void get(Alarm alarm)
    bool set(Alarm alarm)
}
</pre>
<p>where</p>
<dl>
  <dt>PVAlarm</dt>
    <dd>The default constructor. Attach must be called before get or set can be
      called.</dd>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate <b>pvData</b> structure. It looks first a pvField itself
      and if is not an appropriate <b>pvData</b> structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Detaches from the <b>pvData</b> structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to an alarm structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the <b>pvData</b> structure to an Alarm. An exception is
      thrown if not attached to a <b>pvData</b> structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Alarm to the <b>pvData</b> structure. An exception is thrown
      if not attached to a <b>pvData</b> structure. </dd>
</dl>


<h3>timeStamp</h3>
Defined in:
<pre>
pvDataCPP/include/pv/timeStamp.h
and
pvDataCPP/include/pv/pvTimeStamp.h
</pre>
<h4>structure</h4>
<p>A timeStamp is represented by the following structure</p>
<pre>
time_t timeStamp
    long secondsPastEpoch
    int nanoseconds
    int userTag
</pre>

<p>The Epoch is the POSIX epoch, i.e. Jan 1, 1970 00:00:00 UTC. Both the
seconds and nanoseconds are signed integers and thus can be negative. Since the
seconds is kept as a 64 bit integer, it allows for a time much greater than the
present age of the universe. Since the nanoseconds portion is kept as a 32 bit
integer it is subject to overflow if a value that corresponds to a value that
is greater than a little more than 2 seconds or a little less than -2 seconds. The
support code always adjust seconds so that the nanoSecconds part is normalized,
i. e. it has is 0&lt;=nanoseconds&lt;nanoSecPerSec..</p>
<h4>TimeStamp</h4>
<p>The definition of TimeStamp is:</p>
<pre>
TimeStamp {
    void normalize()
    void fromTime_t(time_t time)
    void toTime_t(time_t time
    long getSecondsPastEpoch()
    long getEpicsSecondsPastEpoch()
    int getNanoseconds()
    int getUserTag()
    void setUserTag(int userTag)
    void put(long secondsPastEpoch,int nanoseconds)
    long getMilliSeconds()
    void put(long milliSeconds)
    void getCurrent()
    double toSeconds()
    boolean equals(TimeStamp other)
    boolean lt(TimeStamp other)
    boolean le(TimeStamp other)
    void add(long seconds)
    void add(double seconds)
    double diff(TimeStamp a,TimeStamp b)
}
</pre>
<p>where:</p>
<dl>
  <dt>normalize</dt>
    <dd>Adjust secondsPastEpoch and nanoseconds so that 0&lt;=nanoseconds&lt;nanoSecPerSec.</dd>
  <dt>fromTime_t</dt>
    <dd>Set timeStamp from standard C time</dd>
  <dt>toTime_t</dt>
    <dd>Set time from timeStamp</dd>
  <dt>getSecondsPastEpoch</dt>
    <dd>Get the seconds part of timeStamp</dd>
  <dt>getEpicsSecondsPastEpoch</dt>
    <dd>Get seconds relative to the EPICS epoch. The epics epoch starts on Jan
      1 1990 00:00:00 UTC.</dd>
  <dt>getNanoseconds</dt>
    <dd>Get the nanoseconds part of timeStamp.</dd>
  <dt>getUserTag</dt>
    <dd>Get the userTag</dd>
  <dt>setUserTag</dt>
    <dd>Set the userTag</dd>
  <dt>put(long secondsPastEpoch,int nanoseconds)</dt>
    <dd>Put a value into the timeStamp.</dd>
  <dt>getMilliSeconds</dt>
    <dd>Get the number of milliseconds since the epoch.</dd>
  <dt>put(long milliSeconds);</dt>
    <dd>Put a value into the timeStamp given the number of milliSeconds since
      the epoch.</dd>
  <dt>getCurrent/dt>
    <dd>Get the current time.</dd>
  <dt>toSeconds</dt>
    <dd>Convert the timeStamp to a double value that is seconds past epoch/</dd>
  <dt>equals</dt>
    <dd>Is this time equal other?</dd>
  <dt>lt</dt>
    <dd>Is this time less than other.</dd>
  <dt>le</dt>
    <dd>Is this time less that or equal to other.</dd>
  <dt>add(long seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>add(double seconds)</dt>
    <dd>Add the specified number of seconds.</dd>
  <dt>diff</dt>
    <dd>Compute a-b. The result is in seconds.</dd>
</dl>
<p>The TimeStamp class provides arithmetic and comparison methods for time
stamps. The result is always kept in normalized form, which means that the
nanosecond portion is 0&lt;=nano&lt;nanoSecPerSec. Note that it is OK to have
timeStamps for times previous to the epoch.</p>

<h4>PVTimeStamp</h4>
<pre>
PVTimeStamp {
    bool attach(PVField pvField)
    void detach()
    bool isAttached()
    void get(TimeStamp timeStamp)
    boolean set(TimeStamp timeStamp)
}
</pre>
where
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if a
      timeStamp structure is found. It looks first at pvField itself and if is
      not an appropriate <b>pvData</b> structure but the field name is value it looks
      up the parent structure tree.</dd>
  <dt>detach</dt>
    <dd>Detach from the <b>pvData</b> structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a timeStamp structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the <b>pvData</b> structure to a TimeStamp. An exception is
      thrown if not attached to a <b>pvData</b> structure. </dd>
  <dt>set</dt>
    <dd>Copies data from TimeStamp to the <b>pvData</b> structure. An exception is
      thrown if not attached to a <b>pvData</b> structure. </dd>
</dl>

<h3>display</h3>
Defined in:
<pre>
pvDataCPP/include/pv/display.h
and
pvDataCPP/include/pv/pvDisplay.h
</pre>
<b>NOTE:</b> Should format be replaced by precision and form?
<h4>structure</h4>
<p>Display information is represented by the following structure</p>
<pre>
structure display
    double limitLow
    double limitHigh
    string description
    string format
    string units
</pre>
<h4>Display</h4>
<pre>
Display {
    double getLow()
    double getHigh()
    void setLow(double value)
    void setHigh(double value)
    String getDescription()
    void setDescription(String value)
    String getFormat()                 // broken
    void setFormat(String value)       // broken 
    String getUnits()
    void setUnits(String value)
}
</pre>
<p>where</p>
<dl>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>getDescription</dt>
    <dd>Get the description.</dd>
  <dt>setDescription</dt>
    <dd>Set the description.</dd>
  <dt>getFormat</dt>
    <dd>Get the format.</dd>
  <dt>setFormat</dt>
    <dd>Set the format.</dd>
  <dt>getUnits</dt>
    <dd>Get the units.</dd>
  <dt>setUnits</dt>
    <dd>Set the units.</dd>
</dl>

<h4>PVDisplay</h4>
<pre>
PVDisplay {
    bool attach(PVField pvField)
    void detach()
    bool isAttached()
    void get(Display display)
    bool set(Display display)
}
</pre>

<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>Attempts to attach to <span
     >pvField</span> It returns (false,true) if
      it found an appropriate <b>pvData</b> structure. It looks first a pvField itself
      and if is not an appropriate <b>pvData</b> structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.</dd>
  <dt>detach</dt>
    <dd>Detaches from the <b>pvData</b> structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a display structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the <b>pvData</b> structure to a Display. An exception is
      thrown if not attached to a <b>pvData</b> structure.</dd>
  <dt>set</dt>
    <dd>Copies data from Display to the <b>pvData</b> structure. An exception is
      thrown if not attached to a <b>pvData</b> structure. </dd>
  <dt>create</dt>
    <dd>Create a PVDisplay instance. Attach must be called before get or set
      can be called.</dd>
</dl>

<h3>control</h3>
Defined in:
<pre>
pvDataCPP/include/pv/control.h
and
pvDataCPP/include/pv/pvControl.h
</pre>
<b>NOTE:</b> Should minStep be named maxStep?
<h4>structure</h4>
<p>Control information is represented by the following structure</p>
<pre>
structure control
    double limitLow
    double limitHigh
    double minStep
</pre>
<h4>Control</h4>
The definition for Control is:
<pre>
Control{
    double getLow()
    double getHigh()
    double getMinStep()
    void setLow(double value)
    void setHigh(double value)
    void setMinStep(double value)
}
</pre>

<p>where</p>
<dl>
  <dt>getLow</dt>
    <dd>Get the low limit.</dd>
  <dt>getHigh</dt>
    <dd>Get the high limit.</dd>
  <dt>getMinStep</dt>
    <dd>Get the minimum stepsize.</dd>
  <dt>setLow</dt>
    <dd>Set the low limit.</dd>
  <dt>setHigh</dt>
    <dd>Set the high limit.</dd>
  <dt>setMinStep</dt>
    <dd>Set the minimum stepsize.</dd>
</dl>
<h4>PVControl</h4>
<pre>
PVControl
    boolean attach(PVField pvField)
    void detach()
    boolean isAttached()
    void get(Control control)
    boolean set(Control control)
</pre>
<p>where</p>
<dl>
  <dt>attach</dt>
    <dd>
      Attempts to attach to <span>pvField</span> It returns (false,true) if
      it found an appropriate <b>pvData</b> structure. It looks first a pvField itself
      and if is not an appropriate <b>pvData</b> structure but the field name is value
      it looks to see if the parent structure has an appropriate sub
    structure.
     </dd>
  <dt>detach</dt>
    <dd>Detaches from the <b>pvData</b> structure.</dd>
  <dt>isAttached</dt>
    <dd>Is there an attachment to a control structure?</dd>
  <dt>get</dt>
    <dd>Copies data from the <b>pvData</b> structure to a Control. An exception is
      thrown if not attached to a <b>pvData</b> structure. </dd>
  <dt>set</dt>
    <dd>Copies data from Control to the <b>pvData</b> structure. An exception is
      thrown if not attached to a <b>pvData</b> structure. </dd>
  <dt>create</dt>
    <dd>Create a PVControl instance. Attach must be called before get or set
      can be called.</dd>
</dl>

<h3>valueAlarm</h3>
Defined in:
<pre>
pvDataCPP/include/pv/standardField.h
and
pvDataCPP/include/pv/standardPVField.h
</pre>
<h4>structure</h4>
<p>For each numeric scalar type the following is defined:</p>
<pre>
boolean active
scalarType lowAlarmLimit
scalarType lowWarningLimit
scalarType highWarningLimit
scalarType highAlarmLimit
int lowAlarmSeverity
int lowWarningSeverity
int highWarningSeverity
int highAlarmSeverity
scalarType hysteresis
</pre>
<b>NOTE:</b> I think this should only be defined for double.
<p>For boolean the following is defined:</p>
<pre>
boolean active
int falseSeverity
int trueSeverity
int changeStateSeverity
</pre>
<p>For enum the following is defined:</p>
<pre>
boolean active
int stateSeverity
int changeStateSeverity
</pre>

<h2>Appendix I: Standard for Field::ID</h2>
<p>The introspection interface for every field has an ID, which is available via method:</p>
<pre>
class Field {
...
    string getID();
...
};
</pre>
<p>This section describes how the IDs are assigned.</p>
<h3>Scalar</h3>
<pre>
boolean
byte
short
int
long
ubyte
ushort
ulong
float
double
string
</pre>
<h3>Scalar Array</h3>
<pre>
boolean[]
byte[]
short[]
int[]
long[]
ubyte[]
ushort[]
ulong[]
float[]
double[]
string[]
</pre>
<h3>Union</h3>
<pre>
any        // variant union
union      // restricted union
</pre>
<h3>Union Array</h3>
<pre>
any[]
union[]
</pre>
<h3>structure</h3>
<h4>default</h4>
<pre>
structure
</pre>
<h4>standard fields</h4>
<pre>
alarm_t
time_t
display_t
control_t
enum_t
valueAlarm_t
</pre>

<h3>structure array</h3>
<p>Like structure except that <b>[]</b> is appended.
</p>

<h2>Appendix II: Convert Facility</h2>
<p>
<b>pvDataCPP</b> has a Convert Facility.
The faclity only supports complete array copies between 
two scalar arrays of the same type and only does a shallow copy.
It also does a shallow copy for union, unionArray, and structureArray fields.
It also has a separate facility that does sub-array copies between two
arrays of the same type.
</p>

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays that satisfy one of the following.
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
  <li>Conversion between compatible unions.</li>
  <li>Conversion between compatible union arrays.</li>
  <li>Conversion between compatible structure arrays.</li>
  <li>Support for unsigned integers. Because Java does primitive unsigned
   integers the only support is in "widening" operations.
   For example if a PVUByte is converted to short then the proper conversion will
   be done.</li>
  <li>A utility method the returns the full field name of a field.</li>
</ul>
<pre>
interface Convert {
    void getFullFieldName(StringBuilder builder,PVField pvField)
    void getString(StringBuilder buf,PVField pv, int indentLevel);
    void getString(StringBuilder buf,PVField pv);
    void fromString(PVScalar pv,String from);
    void fromString(PVScalarArray pv,String from);
    int fromStringArray(PVScalarArray pv,
         int offset, int len, String[]from, int fromOffset);
    int toStringArray(PVScalarArray pv,
         int offset, int len, String[]to, int toOffset);
    boolean isCopyCompatible(Field from, Field to);
    void copy(PVField from,PVField to);
    boolean isCopyScalarCompatible(Field from, Field to);
    void copyScalar(PVField from, PVField to);
    boolean isCopyScalarArrayCompatible(ScalarArray from, ScalarArray to);
    int copyScalarArray(PVScalarArray from, int offset,
         PVScalarArray to, int toOffset, int len);
    boolean isCopyStructureCompatible(Structure from, Structure to);
    void copyStructure(PVStructure from, PVStructure to);
    boolean isCopyUnionCompatible(Union from, Union to);
    void copyUnion(PVUnion from, PVUnion to);
    boolean isCopyStructureArrayCompatible(StructureArray from, StructureArray to);
    void copyStructureArray(PVStructureArray from, PVStructureArray to);
    boolean isCopyUnionArrayCompatible(UnionArray from, UnionArray to);
    void copyUnionArray(PVUnionArray from, PVUnionArray to);
    // For the following the pv Type must be PVByte, ...., PVDouble
    byte toByte(PVField pv);
    short toShort(PVField pv);
    int   toInt(PVField pv);
    long  toLong(PVField pv);
    float toFloat(PVField pv);
    double toDouble(PVField pv);
    String toString(PVScalar pv);
    void  fromByte(PVField pv, byte from);
    void  fromShort(PVField pv, short from);
    void  fromInt(PVField pv, int from);
    void  fromLong(PVField pv, long from);
    void  fromUByte(PVField pv, byte from);
    void  fromUShort(PVField pv, short from);
    void  fromUInt(PVField pv, int from);
    void  fromULong(PVField pv, long from);
    void  fromFloat(PVField pv, float from);
    void  fromDouble(PVField pv, double from);
// For the following the element type must be pvByte, ...., pvDouble
    int toByteArray(PVScalarArray pv,
        int offset, int len, byte[]to, int toOffset);
    int toShortArray(PVScalarArray pv,
        int offset, int len, short[]to, int toOffset);
    int toIntArray(PVScalarArray pv,
        int offset, int len, int[]to, int toOffset);
    int toLongArray(PVScalarArray pv,
        int offset, int len, long[]to, int toOffset);
    int toFloatArray(PVScalarArray pv,
        int offset, int len, float[]to, int toOffset);
    int toDoubleArray(PVScalarArray pv,
        int offset, int len, double[]to, int toOffset);
    int fromByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromLongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromUByteArray(PVScalarArray pv,
        int offset, int len, byte[]from, fromOffset);
    int fromUShortArray(PVScalarArray pv,
        int offset, int len, short[]from, fromOffset);
    int fromUIntArray(PVScalarArray pv,
        int offset, int len, int[]from, fromOffset);
    int fromULongArray(PVScalarArray pv,
        int offset, int len, long[]from, fromOffset);
    int fromFloatArray(PVScalarArray pv,
        int offset, int len, float[]from, fromOffset);
    int fromDoubleArray(PVScalarArray pv,
        int offset, int len, double[]from, fromOffset);
    void newLine(StringBuilder builder, int indentLevel);
}
</pre>
<p>The array methods all return the number of elements copied or converted.
This can be less than <span>len</span> if the
PVField array contains less than len elements.</p>

<p><span>newLine</span> is a convenience method
for code that implements <span>toString</span> It
generates a newline and inserts blanks at the beginning of the newline.</p>

<p>The getString methods dump the data in the metadata syntax described in the
pvData project overview. Note that the toString methods of PVField are
implemented by calling these convert methods.</p>

<h4>convert.h</h4>

<pre>
class Convert;
typedef std::tr1::shared_ptr&lt;Convert&gt; ConvertPtr;

class Convert {
public:
    static ConvertPtr getConvert();
    ~Convert();
    void copy(PVFieldPtr const &amp; from, PVFieldPtr const &amp; to);
    void getString(std::string * buf,PVFieldPtr const &amp; pvField,int indentLevel);
    void getString(std::string * buf,PVFieldPtr const &amp; pvField);
    std::size_t fromString(
        PVStructurePtr const &amp;pv,
        StringArray const &amp; from,
        std::size_t fromStartIndex = 0);
    void fromString(PVScalarPtr const &amp; pv, std::string const &amp; from);
    std::size_t fromString(PVScalarArrayPtr const &amp; pv, std::string const &amp;from);
    std::size_t fromStringArray(
        PVScalarArrayPtr const &amp; pv,
        std::size_t offset, std::size_t length,
        StringArray const &amp; from,
        std::size_t fromOffset);
    std::size_t toStringArray(PVScalarArrayPtr const &amp; pv,
        std::size_t offset,
        std::size_t length,
        StringArray &amp; to,
        std::size_t toOffset);
    int8 toByte(PVScalarPtr const &amp; pv);
    int16 toShort(PVScalarPtr const &amp; pv);
    int32 toInt(PVScalarPtr const &amp; pv);
    int64 toLong(PVScalarPtr const &amp; pv);
    uint8 toUByte(PVScalarPtr const &amp; pv);
    uint16 toUShort(PVScalarPtr const &amp; pv);
    uint32 toUInt(PVScalarPtr const &amp; pv);
    uint64 toULong(PVScalarPtr const &amp; pv);
    float toFloat(PVScalarPtr const &amp; pv);
    double toDouble(PVScalarPtr const &amp; pv);
    std::string toString(PVScalarPtr const &amp; pv);
    void fromByte(PVScalarPtr const &amp; pv,int8 from);
    void fromShort(PVScalarPtr const &amp; pv,int16 from);
    void fromInt(PVScalarPtr const &amp; pv, int32 from);
    void fromLong(PVScalarPtr const &amp; pv, int64 from);
    void fromUByte(PVScalarPtr const &amp; pv,uint8 from);
    void fromUShort(PVScalarPtr const &amp; pv,uint16 from);
    void fromUInt(PVScalarPtr const &amp; pv, uint32 from);
    void fromULong(PVScalarPtr const &amp; pv, uint64 from);
    void fromFloat(PVScalarPtr const &amp; pv, float from);
    void fromDouble(PVScalarPtr const &amp; pv, double from);
}

static inline ConvertPtr getConvert() { return Convert::getConvert(); }
</pre>

<h4>pvSubArrayCopy.h</h4>
<p>This supports sub-array copying between arrays that have the same type.</p>
<pre>
template&lt;typename T&gt;
void copy(
    PVValueArray&lt;T&gt; &amp; pvFrom,
    size_t fromOffset,
    size_t fromStride,
    PVValueArray&lt;T&gt; &amp; pvTo,
    size_t toOffset,
    size_t toStride,
    size_t count);

void copy(
    PVScalarArray &amp; from,
    size_t fromOffset,
    size_t fromStride,
    PVScalarArray &amp; to,
    size_t toOffset,
    size_t toStride,
    size_t count);

void copy(
    PVStructureArray &amp; from,
    size_t fromOffset,
    size_t fromStride,
    PVStructureArray &amp; to,
    size_t toOffset,
    size_t toStride,
    size_t count);

void copy(
    PVArray &amp; from,
    size_t fromOffset,
    size_t fromStride,
    PVArray &amp; to,
    size_t toOffset,
    size_t toStride,
    size_t count);
</pre>
<p>The last copy is the only one most client need to call.
It either throws an error if the element types do not match or calls the
other copy functions. The arguments are:</p>
<dl>
   <dt>from</dt>
     <dd>The source array.</dd>
   <dt>fromOffset</dt>
      <dd>The offset into the source array.</dd>
   <dt>fromStride</dt>
       <dd>The interval between source elements.</dd>
   <dt>to</dt>
      <dd>The destination array. The element type must be the same
      as for the source array. If the element type is structure then
      the introspection interface for the element types must be the same.
      </dd>
   <dt>toOffset</dt>
      <dd>The offset into the destination array.</dd>
   <dt>toStride</dt>
       <dd>The interval between destination elements.</dd>
   <dt>count</dt>
      <dd>The  number of elements to copy.</dd>
</dl>
<p>An exception is thrown if:</p>
<dl>
   <dt>type mismatch</dt>
     <dd>The element types for the source and destination differ.</dd>
   <dt>immutable</dt>
      <dd>The destination array is immutable.</dd>
   <dt>capacity immutable</dt>
      <dd>The destination array needs to have it's capacity extended
        but the capacity is immutable.</dd>
</dl>

</div>
</body>
</html>
