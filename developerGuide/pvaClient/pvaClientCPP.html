<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>PvaClient</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>pvaClient</h1>
<h2 class="nocount">editions</h2>
<dl>
  <dt>2021.03.01</dt>
     <dd>Original</dd>
  <dt>2021.04.23</dt>
     <dd>Update</dd>
</dl>  
<dl>
    <dt>Editors:</dt>
   <dd>
      Marty Kraimer
    </dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>

<div id="contents" class="contents">

<h2>Overview</h2>
<p>
This document is the guide for pvaClientCPP, which is one of the components of
<a href="https://epics-controls.org/resources-and-support/base/epics-7/">
EPICS-7
</a>.
<br/>
It is intended for developers that want to use pvaClientCPP.
A guide for developers is available at
<a
href="https://mrkraimer.github.io/website/developerGuide/developerGuide.html">
developerGuide
</a>
</p>
<p>
pvaClient is a synchronous wrapper for the pvAccess API, which is a callback based API.
Thus it is easier to use than pvAccess itself.
In addition pvaClient provides many convenience methods.
</p>
<p>Doxgen for pvaClient is located at:
<a
href="./html/index.html">doxygen
</a>.
</p>

<h2>PvaClient Overview</h2>
<p>
<b>NOTE:</b>
Before reading this overview, clone and build
<a href="https://github.com/epics-base/exampleCPP">
exampleCPP
</a>.
This has examples that are referenced in this overview.
</p>
<p>
<b>pvaClient</b> is support for accessing a single channel.
It provides the following:
</p>
<dl>
   <dt>callbacks</dt>
   <dd>
   The <b>pvAccess</b> client code requires the client to implement callbacks.
   <b>pvaClient</b> implements the callbacks.
   Thus a client is not required to implement callbacks,
   but can optionally implement any desired callback,
   </dd>
   <dt>convenience methods</dt>
   <dd>
   <b>pvaClient</b> provides methods that require much less code by the client.
   These are mainly for channels that have a <b>value</b> field that is either a scalar or scalar array.
   </dd>
   <dt>caching</dt>
   <dd>
   A client can ask to connect to a channel without requiring calls to issueConnect and waitConnect.
   If a connection is made, then the channel is cached.
   This means that if the client makes further requests for the same channel it is already connected.
   <br />
   Caching is also done for channelGets and channelPuts.
   </dd>
</dl>
<p>
The client has many options for how to use pvaClient.
The client be very simple or use additional features.
</p>
<p>Lets take an example that will work for any channel that has a top level value
field which is a numeric scalar.
</p>
An example to get data is:
<pre>
double value = PvaClient::get("pva")->channel(channelName)-&gt;getDouble()
</pre>
<p>The following is psuedo code that shows what pvaClient does:</p>
<pre>
PvaClientPtr pvaClient = getSingleton()
PvaClientChannelPtr pvaClientChannel= getFromChannelCache()
if not in cache
   pvaClientChannel = createChannel(channelName,providerName);
       pvaClientChannel.connect(timeout)
           issueConnect()
           waitConnect(timeout)
           if fail raise exception
   add channel to cache.
PvaClientGetPtr pvaClientGet = getFromGetCache()
if not in cache
   pvaClientGet =createGet()
   pvaClientGet.connect()
      issueConnect()
      waitConnect(timeout)
      if fail raise exception
   add to getCache
pvaClientGet.get()
   issueGet
   waitGet(timeout+
   if fail raise exception
PvaClientGetDataPtr getData = pvaClientGet.getData()
value = getData.getDouble()
   if fail raise exception
return value
</pre>
<p>
An example to put data is:
</p>
<pre>
double value = 1;
PvaClient::get("pva")-&gt;channel(channelName)-&gt;putDouble(value);
</pre>
where <b>channelName</b> is some channel.
<br/>
<b>exampleCPP/pvaClient</b> has <b>shortestPutGetDouble</b>
and <b>shortestPutGetDouble</b>,
which provide example code.
<p>
It is also easy to get/put data to a channel that has a value field that is an array
of any numeric scalar type.
</p>
An example to get data is:
<pre>
shared_vector&lt;double&gt; value = PvaClient::get("pva")-&gt;channel(channelName)-&gt;getDoubleArray()
</pre>
<br/>
An example to put data is:
<pre>
size_t num = 5;
shared_vector&lt;double&gt; data(num,0);
for(size_t i=0; i&lt;num; ++i) data[i] = i;
PvaClient::get("pva")-&gt;channel(channelName)-&gt;putDoubleArray(freeze(data));
</pre>

<p>
Note the following:
</p>
<dl>
   <dt>exceptions</dt>
   <dd>
   If any problems are encountered, an exception is thrown.
   </dd>
   <dt>caching</dt>
   <dd>
   Whenever a channel first connects it is added to a channel cache.
   This is a huge performance improvement when a client makes more than one request.
   <br />
   There is also a cache for channelGets and a cache for channelPuts.
   </dd>
</dl>
<p>
A client can also access channels with a complex structure but has to do more work.
Two features that make this possible are:
</p>
<dl>
   <dt>pvRequest</dt>
   <dd>
   Many methods have a pvRequest argument, which allows the client to specify the set of fields desired.
   </dd>
   <dt>pvaClientData</dt>
   <dd>
   The data for a channel is made available via pvaClientData.
   One of the methods is getPVStructure, which gets the entire data for a particular pvRequest.
   </dd>
</dl>
<p>
The next section is a tutorial based on examples from exampleCPP/exampleClient.
The remaining sections provide a brief summary of all methods provided by <b>pvaClient</b>
<br/>
Look at
<a
href="./html/index.html">doxygen
</a>
for details about each method,
</p>
<h2>Tutorial</h2>

<h3>Non-blocking Examples</h3>
<p>These are examples that never block while waiting for a channel to connect.
They are good examples for use by display manager tools that want to access channels
via pvAccessCPP. The examples all use pvaClientCPP rather than pvAccessCPP itself.
</p>
<p>Each example implements a class that can be used as a starting point for
imlementing pvAccess channel connections for a display manager.
</p>
<h4>get</h4>
<p>This example uses PvaClientGet. It supports help as follows:</p>
<pre>
mrk> bin/linux-x86_64/get -help
-p provider -r request -d debug channelNames
default
-p pva -r value,alarm,timeStamp -d false PVRdouble
mrk> 
</pre>
The arguments are:
<dl>
   <dt>provider</dt>
     <dd>
      This can be either <b>pva</b> or <b>ca</b>.
      <b>ca</b> only works if channelName is a accessable via the ca network protocol,
      e. g. it is the name of a DBRecord in a V3 IOC.
     </dd>
   <dt>request</dt>
     <dd>
      The request for creating the channel get,
     </dd>
   <dt>debug</dt>
     <dd>
      If true then debug messages are displayed.
     </dd>
   <dt>channelNames</dt>
     <dd>
       A list of channel names.
     </dd>

</dl>

<p>
When the example is started a PvaClientChannel is created and issueConnect is called.
The first time the channel connects a PvaChannelGet is created and issueConnect is called.
</p>
<p>The example then enters a forever loop the lets the client enter commands.
Two commands are accepted:</p>
<dl>
   <dt>exit</dt>
     <dd>The example terminates.</dd>
   <dt>get</dt>
     <dd>A channel get is requested. The results are displayed.</dd>
</dl>

<p>
Note that if a channel disconnects and reconnects between gets the example should continuue
to work.
</p>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/get PVRdouble PVRshort
provider pva channelName PVRdouble request value,alarm,timeStamp debug false
_____get starting__
Type exit to stop: 
channelGetConnect PVRdouble status Status [type=OK]
channelGetConnect PVRshort status Status [type=OK]

channelGetDone PVRdouble status Status [type=OK]
changed PVRdouble
 = structure 
    double value 0
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0

bitSet {0}
channelGetDone PVRshort status Status [type=OK]
changed PVRshort
 = structure 
    short value 0
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 0
        int nanoseconds 0
        int userTag 0

bitSet {0}
Type exit to stop: 
</pre>
<h4>put</h4>
<p>This example uses PvaClientPut. It supports help as follows:</p>
<pre>
mrk> bin/linux-x86_64/put -help
-p provider -r request -d debug channelNames
default
-p pva -r value -d false PVRdouble
mrk> 
</pre>
The arguments are:
<dl>
   <dt>provider</dt>
     <dd>
      This can be either <b>pva</b> or <b>ca</b>.
      <b>ca</b> only works if channelName is a accessable via the ca network protocol,
      e. g. it is the name of a DBRecord in a V3 IOC.
     </dd>
   <dt>request</dt>
     <dd>
      The request for creating the channel put,
     </dd>
   <dt>debug</dt>
     <dd>
      If true then debug messages are displayed.
     </dd>
   <dt>channelNames</dt>
     <dd>
       A list of channel names.
     </dd>

</dl>

<p>
When the example is started a PvaClientChannel is created and issueConnect is called.
The first time the channel connects a PvaChannelPut is created and issueConnect is called.
</p>
<p>The example then enters a forever loop the lets the client enter commands.
Two commands are accepted:</p>
<dl>
   <dt>exit</dt>
     <dd>The example terminates.</dd>
    <dt>put</dt>
     <dd>A channel put is requested</dd>
   <dt>get</dt>
     <dd>A PvaChannelPut::get is requested. The results are displayed.</dd>
</dl>

<p>
Note that if a channel disconnects and reconnects between gets the example should continuue
to work.
</p>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/put -help
 -h -p provider -r request - d debug channelNames 
default
-p pva -r value -d false PVRdouble
mrk> bin/linux-x86_64/put PVRdouble PVRshort
provider pva channelName PVRdouble request value debug false
_____put starting__
enter one of: exit put get
channelPutConnect PVRdouble status Status [type=OK]
channelPutConnect PVRshort status Status [type=OK]
put
enter value or values to put
4
getDone PVRdouble status Status [type=OK]
structure 
    double value 0

putDone PVRdouble status Status [type=OK]
getDone PVRshort status Status [type=OK]
structure 
    short value 4

enter one of: exit put get
putDone PVRshort status Status [type=OK]
get
enter one of: exit put get
getDone PVRdouble status Status [type=OK]
structure 
    double value 4

getDone PVRshort status Status [type=OK]
structure 
    short value 4


</pre>
<h4>putGet</h4>
<p>This example uses pvaClientPutGet. It supports help as follows:</p>
<pre>
mrk> bin/linux-x86_64/putGet -help
-p provider -r request -d debug channelNames
default
-p pva -r putField(argument)getField(result) -d false PVRhelloPutGet
mrk> 
</pre>
The arguments are:
<dl>
   <dt>provider</dt>
     <dd>
      This can be either <b>pva</b> or <b>ca</b>.
      <b>ca</b> only works if channelName is a accessable via the ca network protocol,
      e. g. it is the name of a DBRecord in a V3 IOC.
     </dd>
   <dt>request</dt>
     <dd>
      The request for creating the channel putGet,
     </dd>
   <dt>debug</dt>
     <dd>
      If true then debug messages are displayed.
     </dd>
   <dt>channelNames</dt>
     <dd>
       A list of channel names.
     </dd>

</dl>

<p>
When the example is started a PvaClientChannel is created and issueConnect is called.
The first time the channel connects a PvaChannelGet is created and issueConnect is called.
</p>
<p>The example then enters a forever loop the lets the client enter commands.
Two commands are accepted:</p>
<dl>
   <dt>exit</dt>
     <dd>The example terminates.</dd>
   <dt>putGet</dt>
     <dd>A putGet is requested. The results are displayed.</dd>
   <dt>getPut</dt>
     <dd>A getPut is requested. The results are displayed.</dd>
   <dt>getGet</dt>
     <dd>A getGet is requested. The results are displayed.</dd>
</dl>

<p>
Note that if a channel disconnects and reconnects between gets the example should continuue
to work.
</p>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/putGet
provider pva channelName PVRhelloPutGet request putField(argument)getField(result) debug false
_____put starting__
enter one of: exit putGet getPut getGet
channelPutGetConnect PVRhelloPutGet status Status [type=OK]
putGet
enter value
Marty
structure 
    structure result
        string value "Hello 3"

structure 
    structure argument
        string value 3

structure 
    structure result
        string value "Hello Marty"

enter one of: exit putGet getPut getGet
getPut
enter one of: exit putGet getPut getGet
structure 
    structure argument
        string value Marty

getGet
enter one of: exit putGet getPut getGet
structure 
    structure result
        string value "Hello Marty"
</pre>
<h4>monitor</h4>
<p>This example uses pvaClientMonitor. It supports help as follows:</p>
<pre>
mrk> bin/linux-x86_64/monitor -help
-p provider -r request -d debug channelNames
default
-p pva -r value,alarm,timeStamp -d false PVRdouble
mrk> 
</pre>
The arguments are:
<dl>
   <dt>provider</dt>
     <dd>
      This can be either <b>pva</b> or <b>ca</b>.
      <b>ca</b> only works if channelName is a accessable via the ca network protocol,
      e. g. it is the name of a DBRecord in a V3 IOC.
     </dd>
   <dt>request</dt>
     <dd>
      The request for creating the channel get,
     </dd>
   <dt>debug</dt>
     <dd>
      If true then debug messages are displayed.
     </dd>
   <dt>channelNames</dt>
     <dd>
       A list of channel names.
     </dd>

</dl>

<p>
When the example is started a PvaClientChannel is created and issueConnect is called.
The first time the channel connects a PvaChannelMonitor is created and issueConnect is called.
</p>
<p>The example then enters a forever loop the lets the client enter commands.
Two commands are accepted:</p>
<dl>
   <dt>exit</dt>
     <dd>The example terminates.</dd>
   <dt>stop</dt>
     <dd>A stop request is issued</dd>
    <dt>start</dt>
     <dd>The client is asked to enter a new request and then
       PvaChannelMonitor::start is called with the new request.
    </dd>
</dl>

<p>
Note that if a channel disconnects and reconnects between gets the example should continuue
to work.
</p>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/monitor -help
 -h -p provider -r request - d debug channelNames 
default
-p pva -r value,alarm,timeStamp -d false PVRdouble
mrk> bin/linux-x86_64/monitor PVRdouble PVRshort
provider pva channelName PVRdouble request value,alarm,timeStamp debug false
_____get starting__
channelStateChange PVRdouble isConnected false
channelStateChange PVRshort isConnected false
Enter: exit start stop
channelStateChange PVRdouble isConnected true
monitorConnect PVRdouble status Status [type=OK]
event PVRdouble
monitor 
changed
 = structure 
    double value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619184903
        int nanoseconds 418736113
        int userTag 0

overrun
channelStateChange PVRshort isConnected true
monitorConnect PVRshort status Status [type=OK]
event PVRshort
monitor 
changed
 = structure 
    short value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619184903
        int nanoseconds 419209576
        int userTag 0

overrun

Enter: exit start stop
</pre>
<h4>getField.</h4>
<p>This is an example that calls <b>Channel::getField</b> , i. e.
it gets the introspection interface for a field of a channel.
</p>
<p>This example supports help as follows:</p>
<pre>
mrk> bin/linux-x86_64/getField -help
 -h -p provider - d debug channelNames 
default
-p pva -d false PVRdouble
</pre>
<p>After it is started than each time you enter a field name
the introspection interface for the specified field is displayed.
A null field name returns the complete introspection interface for the channel.
When <b>exit</b> is entered the example terminates.
</p>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/getField PVRdouble
provider pva channelName PVRdouble debug false
_____getField starting__
Type exit, or a fieldname, or just enter return

Type exit, or a fieldname, or just enter return
getDone
structure
    double value
    time_t timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
    alarm_t alarm
        int severity
        int status
        string message

value
Type exit, or a fieldname, or just enter return
getDone
double

Type exit, or a fieldname, or just enter return
getDone
structure
    double value
    time_t timeStamp
        long secondsPastEpoch
        int nanoseconds
        int userTag
    alarm_t alarm
        int severity
        int status
        string message

exit
</pre>

<h4>putUnion</h4>
<p>This is another example that creates a PvaClientPut that never blocks.
It automatically handles channel connect and disconnects and also creates a PvaClientPut when the channel first connects.
</p>
<p>
The example implements a class <b>ClientPut</b>, which implements PvaClientChannelStateChangeRequester,
and PvaClientPutRequester.
</p>
<p>
This example must be connected to a field that has type <b>pvUnion</b>.
</p>
<p>This example supports help as follows:</p>
<pre>
mrk> bin/linux-x86_64/putUnion -help
 -h -p provider -r request - d debug channelNames 
default
-p pva -r value -d false PVRrestrictedUnion
</pre>
The arguments are:
<dl>
   <dt>channelName</dt>
     <dd>
       The name of the channel.
     </dd>
   <dt>request</dt>
     <dd>A request as defined in the convert facility of pvData</dd>
   <dt>debug</dt>
     <dd>
      If true then debug messages are displayed/
     </dd>
</dl>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/putUnion
provider pva channelName PVRrestrictedUnion request value debug false
_____putUnion starting__
Type exit to stop: 
channelPutConnect PVRrestrictedUnion status Status [type=OK]

value 
putDone PVRrestrictedUnion status Status [type=OK]
Type exit to stop: 
exit
mrk> bin/linux-x86_64/putUnion
provider pva channelName PVRrestrictedUnion request value debug false
_____putUnion starting__
Type exit to stop: 
channelPutConnect PVRrestrictedUnion status Status [type=OK]
2
value 2
putDone PVRrestrictedUnion status Status [type=OK]
Type exit to stop: 
exit

pvget PVRrestrictedUnion
PVRrestrictedUnion epics:nt/NTUnion:1.0 
    union value
        string  2
    time_t timeStamp 2021-04-23 09:51:33.365  
        long secondsPastEpoch 1619185893
        int nanoseconds 365061410
        int userTag 0

</pre>
<h4>process</h4>
<p>This is an example that issues a request to process a record.
It supports help as follows:
</p>
<pre>
bin/linux-x86_64/process -help
 -h - d debug channelNames 
default
 -d false PVRdouble
</pre>
<p>An example is:
</p>
<pre>
bin/linux-x86_64/process PVRdouble
 channelName PVRdouble debug false
_____process starting__
exit or enter
channelProcessConnect PVRdouble status Status [type=OK]

processDone PVRdouble status Status [type=OK]
exit or enter
exit
</pre>
<h4>addRecord</h4>
<p>
This is an example that issues a call a record that can add a record to an existing PVDatabase.
<br/>
An example is:
</p>
<pre>
bin/linux-x86_64/addRecord  PVRaddRecord PVRdouble temp
result=structure 
    structure result
        string status success

pvinfo temp
temp
Server: 10.0.0.194:5075
Type:
    structure
        double value
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
        alarm_t alarm
            int severity
            int status
            string message
</pre>


<h4>multiPutDouble</h4>
<p>This an example that uses <b>PvaClientMultiPutDouble</b>.
</p>
<pre>
bin/linux-x86_64/multiPutDouble -help
 -h -p provider -d debug  channelNames 
default
 -d  {10}[PVRbyte, PVRshort, PVRint, PVRlong, PVRubyte, PVRushort, PVRuint, PVRulong, PVRfloat, PVRdouble]

</pre>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/multiPutDouble
_____multiPutDouble starting_______
 channelNames {10}[PVRbyte, PVRshort, PVRint, PVRlong, PVRubyte, PVRushort, PVRuint, PVRulong, PVRfloat, PVRdouble]
Type exit or enter to put

first element
2
data={10}[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
put data ={10}[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
after put data
Type exit or enter to put
exit
_____multiPutDouble done_______
</pre>

<h4>multiMonitorDouble</h4>
<p>This an example that uses <b>PvaClientMultiMonitorDouble</b>.
</p>
<pre>
bin/linux-x86_64/multiMonitorDouble -help
 -h -p provider -d debug  channelNames 
default
 -d  {10}[PVRbyte, PVRshort, PVRint, PVRlong, PVRubyte, PVRushort, PVRuint, PVRulong, PVRfloat, PVRdouble]
</pre>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/multiMonitorDouble
_____multiMonitorDouble starting_______
 channelNames {10}[PVRbyte, PVRshort, PVRint, PVRlong, PVRubyte, PVRushort, PVRuint, PVRulong, PVRfloat, PVRdouble]
Type exit or enter to poll

value={10}[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Type exit or enter to poll
exit
_____multiMonitorDouble done_______
</pre>

<h4>multiGetDouble</h4>
<p>This an example that uses <b>PvaClientMultiGetDouble</b>.
</p>
<pre>
 bin/linux-x86_64/multiGetDouble -help
 -h -p provider -d debug  channelNames 
default
 -d  {10}[PVRbyte, PVRshort, PVRint, PVRlong, PVRubyte, PVRushort, PVRuint, PVRulong, PVRfloat, PVRdouble]
</pre>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/multiGetDouble
_____multiGetDouble starting_______
 channelNames {10}[PVRbyte, PVRshort, PVRint, PVRlong, PVRubyte, PVRushort, PVRuint, PVRulong, PVRfloat, PVRdouble]
Type exit or enter to get

value={10}[0, 4, 0, 0, 0, 0, 0, 0, 0, 4]
Type exit or enter to get
exit
_____multiGetDouble done_______
</pre>
<h4>ntMultiPut</h4>
<p>This an example that uses <b>PvaClientNTMultiPut</b>.
</p>
<pre>
bin/linux-x86_64/ntMultiPut -help
 -h -p provider - d debug channelNames 
default
-p pva -d false {9}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray, PVRvariantUnion]
</pre>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/ntMultiPut -help
 -h -p provider - d debug channelNames 
default
-p pva -d false {9}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray, PVRvariantUnion]
mrk> bin/linux-x86_64/ntMultiPut
_____ntMultiPut starting_______
 channelNames {9}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray, PVRvariantUnion]
Type exit or enter to put

enter value
4
Type exit or enter to put
exit
___ntMultiPut done_______

pvget PVRvariantUnion
PVRvariantUnion epics:nt/NTUnion:1.0 
    any value
        string  4
    time_t timeStamp 2021-04-23 10:54:17.944  
        long secondsPastEpoch 1619189657
        int nanoseconds 943713188
        int userTag 0
</pre>

<h4>ntMultiMonitor</h4>
<p>This an example that uses <b>PvaClientNTMultiMonitor</b>.
</p>
<pre>
bin/linux-x86_64/ntMultiMonitor -help
 -h -p provider -r request -v valueOnly - d debug channelNames 
default
-p pva -r value,alarm,timeStamp -v false -d false {8}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray]
</pre>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/ntMultiMonitor
_____ntMultiMonitor starting_______
 channelNames {8}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray]
Type exit or enter to poll

PVRbyte = structure 
    byte value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943653531
        int userTag 0

PVRshortArray = structure 
    short[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943675894
        int userTag 0

PVRint = structure 
    int value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943682101
        int userTag 0

PVRlongArray = structure 
    long[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943687594
        int userTag 0

PVRubyte = structure 
    ubyte value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943691279
        int userTag 0

PVRushortArray = structure 
    ushort[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943695179
        int userTag 0

PVRdouble = structure 
    double value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943701211
        int userTag 0

PVRdoubleArray = structure 
    double[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943706137
        int userTag 0

Type exit or enter to poll
no new data
Type exit or enter to poll
exit
_____ntMultiMonitor done_______

</pre>

<h4>ntMultiGet</h4>
<p>This an example that uses <b>PvaClientNTMultiGet</b>.
</p>
<pre>
bin/linux-x86_64/ntMultiGet -help
 -h -p provider -r request -v valueOnly - d debug channelNames 
default
-p pva -r value,alarm,timeStamp -v false -d false {8}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray]
</pre>
<p>
An example is:
</p>
<pre>
bin/linux-x86_64/ntMultiGet 
_____ntMultiGet starting_______
 channelNames {8}[PVRbyte, PVRshortArray, PVRint, PVRlongArray, PVRubyte, PVRushortArray, PVRdouble, PVRdoubleArray]
Type exit or enter to get

PVRbyte = structure 
    byte value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943653531
        int userTag 0

PVRshortArray = structure 
    short[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943675894
        int userTag 0

PVRint = structure 
    int value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943682101
        int userTag 0

PVRlongArray = structure 
    long[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943687594
        int userTag 0

PVRubyte = structure 
    ubyte value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943691279
        int userTag 0

PVRushortArray = structure 
    ushort[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943695179
        int userTag 0

PVRdouble = structure 
    double value 4
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943701211
        int userTag 0

PVRdoubleArray = structure 
    double[] value [4]
    alarm_t alarm
        int severity 0
        int status 0
        string message 
    time_t timeStamp
        long secondsPastEpoch 1619189657
        int nanoseconds 943706137
        int userTag 0

Type exit or enter to get
exit
_____ntMultiGet done_______

</pre>

<h3>Blocking Examples</h3>
<p>These are examples only work if a channel is already connected when the client starts.
They are examples that could be used by scripting tools.
</p>

<h4>examplePvaClientGet</h4>
<p>This has a number of examples:</p>
<dl>
   <dt>exampleDouble</dt>
      <dd>
         This shows both a short and long way to get data from a scalar channel.
         The short way throws an execption if the request fails.
         The long way allows the client more control of looking for problems and blocking.
     </dd>
   <dt>exampleDoubleArray</dt>
      <dd>
         Like exampleDouble except the data is a scalarArray.
     </dd>
</dl>

<h4>examplePvaClientMonitor</h4>
<p>This is an example of creating a monitor on a channel.
It monitors a scalar double field.
It also issues puts to the same channel so that it can make the monitors occur.
</p>
<h4>examplePvaClientPut</h4>
<p>This has the folllowing examples:</p>
<dl>
   <dt>exampleDouble</dt>
     <dd>This shows use of get, put, and monitor to a numeric scalar field.</dd>
   <dt>exampleDoubleArray</dt>
     <dd>This shows use of get, put, and monitor to a numeric scalar array field.</dd>
</dl>
<h4>examplePvaClientProcess</h4>
<p>This example makes a process request to a channel.</p>

<h4>examplePvaClientMultiDouble</h4>
<p>This is an example of using pvaClientMultiChannel,
pvaClientMultiGetDouble, pvaClientMultiPutDouble, and pvaClientMultiMonitorDouble.
</p>
<h4>examplePvaClientNTMulti</h4>
<p>This is an example of using pvaClientMultiChannel to get data as an NTMultiChannel.</p>
<h4>helloWorldPutGet</h4>
<p>This is an example of issuing a channelPutGet.</p>
<h4>helloWorldRPC</h4>
<p>This is an example of issuing a PvaClientRPC request.
</p>

<h3>testRequest</h3>
<p>This provides a way to run <b>CreateRequest</b> by providing a string that is passed to
createRequest.</p>
<p>Some examples are:</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/exampleClient
mrk> bin/linux-x86_64/testRequest
enter a string to pass to createRequest
mrk> bin/linux-x86_64/testRequest value
pvRequest
structure 
    structure field
        structure value
mrk> bin/linux-x86_64/testRequest "record[block=true],field(value[max_elem=1],alarm.timeStamp)"
pvRequest
structure 
    structure record
        structure _options
            string block true
    structure field
        structure value
            structure _options
                string max_elem 1
        structure alarm
            structure timeStamp
</pre>

<h2>PvaClient</h2>
<h3>Brief Description</h3>
<p><b>PvaClient</b> has methods:</p>
<pre>
get              Get the single instance of PvaClient.
channel          Creates a channel and connects.
                 This blocks and can throw an exception.
createChannel    Create a channel without blocking.
setRequester     Set a message requester. Client can optionally call this.
getRequesterName Get the requester name.
message          Generate a message. Any code can call this.
clearRequester   Let pvaClient handle calls to message and getRequesterName.
showCache        Show the current channels in the cache.
cacheSize        Show the number of channels in the cache.
setDebug         Set if debug messages should be generated.
getDebug         Get the current debug status.
</pre>
<p>
Class <b>PvaClient</b> is a class that is used by all the other pvaClient classes.
An application that uses pvaClient must call:</p>
<pre>
PvaClientPtr pvaClient = PvaClient::get(providers);
</pre>
<p>
before it uses any other pvaClient classes.
</p>
<p>
This is a singleton method, i. e. only one instance of PvaClient is created.
</p>

<p>
<b>providers</b> is a blank separated set of provider names.
For example:</p>
<pre>
PvaClientPtr pvaClient = PvaClient::get("ca pva");
</pre>
<p>
The providers <b>ca</b> and <b>pva</b> are special.
For each of these a client context is created when the <b>PvaClient</b>
is constructed and the context destroyed when <b>PvaClient</b> is deleted.
</p>
<h3>Requester</h3>
<p>This is a class defined in <b>pvAccessCPP</b>.
It's main method is <b>message</b>, which code calls when it wants to  pass messages to the client.
A client that calls PvaClient::setRequester must implememt this class.
</p>
<p>
It has two methods:
</p>
<dl>
    <dt>getRequesterName</dt>
      <dd>
      The client must implement this method.
      The value is up to the client.
      </dd>
    <dt>message</dt>
      <dd>
      This is called whenever any message is being generated.
      If the client does not call PvaClient::setRequester then PvaClient displays the message on stdout.
      </dd>    
</dl>
<h3>Channel Caching</h3>
<p>
<b>PvaClient</b> has a method:
</p>
<pre>
PvaClientChannelPtr channel(
    string const &amp; channelName,
    string const &amp;providerName = "pva",
    double timeOut = 5.0);
</pre>
<p>
This method creates a
<b>PvaClientChannel</b> and then connects to the channel.
</p>
<p>
If a call is successful then multiple calls to the same channelName and providerName
share the same PvaClientChannel, i. e. the PvaClientChannel is cached.
</p>
<p>
<b>pvaClientChannelGet</b> and <b>pvaClientChannelPut</b> also implement caching.
</p>
<p>
For example consider a client that makes multiple calls like:
</p>
<pre>
double value;
value =  pva->channel(channelName)->get()->getData()->getDouble();
...
value =  pva->channel(channelName)->get()->getData()->getDouble();
</pre>
<p>
Only the first call creates a new PvaClientChannel and a new PvaClientGet.
The second call reuses the cached PvaClientChannel and PvaClientGet.
</p>
<h4>PERFORMANCE NOTE:</h4>
<p>
If a client connects to many channels then the
caching methods can cause poor network performance.
</p>
<h3>Non Cached Channels</h3>
<p>
<b>PvaClient</b> has a method:
</p>
<pre>
PvaClientChannelPtr createChannel(
    string const &amp; channelName,
    string const &amp;providerName = "pva");
</pre>
<p>
This method is just creates a new PvaClientChannel and returns it to the caller.
The caller must call the PvaClientChannel connect methods.
</p>

<h2>PvaClientChannel</h2>
<h3>Brief Description</h3>
<p><b>PvaClientChannel</b> has methods:</p>
<pre>
The following are for connecting to a channel.
connect      Calls issueConnect and then waitConnect.
             This blocks and can throw an exception.
issueConnect Issue a connection request and return.
waitConnect  Wait until the channel connects.
             It returns Status, wich shows if channel connects.

The following are for getting data from a channel.
Except for createGet, all can throw an exception.
get             Get a PvaChannelGet from the cache or create a PvaChannelGet and connect.
createGet       Create a PvaChannelGet.
getDouble       Calls get and then get data as a double.
getString       Calls get and then get data as a string.
getDoubleArray  Calls get and then get data as a double array.
getStringArray  Calls get and then get data as a string array.

The following are for putting data to a channel.
Except for createPut, all can throw an exception.
put             Get a PvaChannelPut from the cache or create a PvaChannelPut and connect.
createPut       Create a PvaChannelPut.
putDouble       Put a double to the channel.
putString       Put s string to the channel.
putDoubleArray  Put an array of doubles to the channel.
putStringArray  Put an array of strings to the channel.

The following creates a PvaClientPutGet
createPutGet    Create a PvaChannelPutGet.

The following creates a PvaClientMonitor
monitor        Create a PvaChannelMonitor.
               Can throw an exception.
createMonitor  Create a PvaChannelMonitor.

The following creates a PvaClientProcess
createProcess  Create a PvaChannelProcess.

The following are for remote procedure calls.
rpc             Issues a PvaClientRPC request and returns result.
                Can throw an exception.
createRPC       Creates a PvaClientRPC. 

The following are convience methods
getChannelName  Get the name of the channel
getChannel      This is the pvAccces channel
showCache       Show what is in the channel cache.
cacheSize       Show the number of channels in the cache.

The following can optionally be called by the client to receive state changes
setStateChangeRequester Specify the client callback.

The following are methods of pvAccess:ChannelRequester
getRequesterName    Get the name of the requester.
message             Generate a message.
channelCreated      Client should never call this.
channelStateChange  Client should never call this.
</pre>
<p>
pvaClientChannel is a synchronous wrapper for the pvAccess::Channel API, which is a callback based API.
Thus it is easier to use than pvAccess::Channel itself.
</p>
<p>An instance of <b>PvaClientChannel</b> connects to a single channel.
<br />
An instance can only be created via class <b>PvaClient</b> which has both synchronous methods, which block, and non blocking methods.
The synchrouous methods block until a connection is made to the channel and throw an exception if a 
timeout occurs while trying to make a connection.
The non blocking methods leave connection to the caller.
</p>

<h3>Connect: Blocking vs Non-Blocking </h3>
<p><b>PvaClientChannel</b> has methods:</p>
<dl>
    <dt>connect</dt>
       <dd>
        This calls issueConnect and then waitConnect.
        If waitConnect fails an exception is thrown.
        Since waitConnect is a blocking method so is this.
       </dd>
    <dt>issueConnect</dt>
       <dd>
         This is a request to connect to the channel. This is a non blocking call.
       </dd>
    <dt>waitConnect</dt>
       <dd>
         This waits for the server to respond to issueConnect.
         It blocks until the server responds or a timeout occurs.
       </dd>
</dl>

<h3>Get and Put Caching</h3>
<p>
<b>PvaClientChannel</b> has methods:
</p>
<pre>
PvaClientGetPtr get(std::string const &amp; request);
PvaClientPutPtr put(std::string const &amp; request);
</pre>
<p>
Each of these caches.
For example all calls to <b>get</b> with the same <b>request</b> will share the same
<b>PvaChannelGet</b>
</p>
<p>
For example consider a client that makes multiple calls like:
</p>
<pre>
double value;
value =  pva->channel(channelName)->get()->getData()->getDouble();
...
value =  pva->channel(channelName)->get()->getData()->getDouble();
</pre>
<p>
Only the first call creates a new PvaClientChannel and a new PvaClientGet.
The second call reuses the cached PvaClientChannel and PvaClientGet.
</p>
<h3>PvaClientChannelStateChangeRequester</h3>
<p>
<b>PvaClientChannel</b> has method <b>setStateChangeRequester</b>
<b>PvaClientChannelStateChangeRequester</b> has the single method <b>channelStateChange</b>.
It is called each time the channel connection status changes.
</p>
<p>
<b>NOTE:</b>
The implementation must not call a method that blocks waiting for a response from the server.
It it does the client may be blocked forever.
</p>
<p>
An example of illegal code is:
</p>
<pre>
virtual void channelStateChange(PvaClientChannelPtr const &amp; channel, bool isConnected)
{
    if(isConnected&amp;&amp;!pvaClientPut)
    {
       pvaClientPut  = pvaClientChannel->createPut(request);
       pvaClientPut->connect();
    }
}
</pre>
<p>
This is illegal because the call to <b>connect</b> blocks.
</p>
<p>The following is an example of legal code:
</p>
<pre>
virtual void channelStateChange(PvaClientChannelPtr const &amp; channel, bool isConnected)
{
    if(isConnected&amp;&amp;!pvaClientPut)
    {
       pvaClientPut  = pvaClientChannel->createPut(request);
       pvaClientPut->issueConnect();
    }
}
</pre>
<p>This is legal code because neither <b>createPut</b> or <b>issueConnect</b>
blocks.
</p>

<h2>pvaClientData</h2>
<h3>PvaClientData</h3>
<p>This is a base class for <b>pvaClientGetData</b>, <b>pvaClientPutData</b>, and <b>pvaClientMonitorData</b>
</p>
<p>This class provides methods:</p>
<pre>
getStructure          Get the introspection interface.
getPVStructure        Get the data.
getChangedBitSet      Get a bitset that shows which fields have changed.
showChanged           Show the fields that have changed value.
hasValue              Is the value field a scalar?
NOTE: The following only apply if hasValue is true.
isValueScalar         Is the value field a scalar?
isValueScalarArray    Is the value field a scalar array?
getValue              Get the value field.
getScalarValue        Get a scalar value field.
getArrayValue         Get an array value field.
getScalarArrayValue   Get a scalar array value field.
getDouble             Get scalar value field as a double.
getString             Get value field as a string.
getDoubleArray        Get value field as a double array.
getStringArray        Get value field as a string array.
getAlarm              Get the top level alarm field if it exists.
getTimeStamp          Get the top level timeStamp field if it exists.
parse                 Accepts arguments of the form json or field='value',
                      where value is json syntax.
streamJSON            Generates JSON output from the current PVStructure,
                      and displays it on the output stream.
zeroArrayLength       Sets the length of all array fields to 0.

create                NOT called by client code
setMessagePrefix      NOT called by client code.
setData               NOT called by client.
</pre>

<h3>PvaClientGetData</h3>
<p>This class provides access to the data returned by the server via <b>PvaChannelGet</b>
or <b>PvaChannelPutGet</b>.
Thus the client only gets access to an instance by getting it from <b>PvaChannelGet</b> or <b>PvaChannelPutGet</b>.
</p>
<p>
It provides all the methods from the base class <b>PVaClientData</b> and does not add any methods.
</p>
<h3>PvaClientPutData</h3>

<p>This class provides access to data to send to the server via a <b>PvaChannelPut</b>.
It is created by <b>PvaChannelPut</b> or <b>PvaChannelPutGet</b>.
Thus the client only gets access to an instance by getting it from <b>PvaChannelPut</b> or <b>PvaChannelPutGet</b>.
</p>
<p>Note also that for all field types except <b>union</b> the <b>BitSet</b> for the data is updated
by <b>PvaChannelPut</b> or <b>PvaChannelPutGet</b> whenever the client changes a field.
For a <b>union</b> or <b>unionArray</b> field the client must update the <b>BitSet</b>.
</p>

<p>
It provides all the methods from the base class <b>PVaClientData</b>.
PvaClientPutData provides the additional methods:</p>
<pre>
putDouble             Put scalar value field as a double.
putString             Put value field as a string.
putDoubleArray        Put value field as a double array.
putStringArray        Put value field as a string array.
</pre>

<h3>PvaClientMonitorData</h3>

<p>This class provides access to the data returned by calls to get data via <b>PvaChannelMonitor</b>
</p>
<p>
It provides all the methods from the base class <b>PVaClientData</b>.
PvaClientMonitorData provides the additional methods:
</p>

<pre>
getOverrunBitSet      How many fields have changed more than once since last monitor event.
showOverrun           Show the fields that have changed more than once since the last monitor event.
setData               NOT called by client.
create                NOT called by client
</pre>


<h2>PvaClientGet</h2>
<h3>Brief Description</h3>
<p><b>PvaClientGet</b> has methods:</p>
<pre>
connect             Calls issueConnect and then waitConnect.
issueConnect        Issues a request to the server to create the server side of ChannelGet.
waitConnect         Blocks until server responds that it has created the ChannelGet.
get                 Calls issueGet and then waitGet.
issueGet            Issues a get request to the server.
waitGet             Blocks until the server send a message that the get is complete.
getData             Get the PvaClientGetData. Should only be called after get or waitGet.
setRequester        Set a pvaClientGetRequester.
getPvaClientChannel Get the PvaClientChannel.
</pre>
<p>An instance of PvaClientGet is created via a call to one of the following:</p>
<pre>
class PvaClientChannel
...
{
...
    PvaClientGetPtr get(std::string const &amp; request = "field(value,alarm,timeStamp)");
    PvaClientGetPtr createGet(std::string const &amp; request = "");
    PvaClientGetPtr createGet(epics::pvData::PVStructurePtr const &amp;  pvRequest);
...
};
</pre>

<h3>PvaClientGetRequester</h3>
<p>This is a virtual class that can be implemented by a client that uses <b>PvaClientGet</b>.
It has the methods:</p>
<pre>
virtual void channelGetConnect(
    const Status&amp; status,
    PvaClientGetPtr const &amp;&amp; clientGet) {}
virtual void getDone(
    const Status&amp; status,
    PvaClientGetPtr const &amp; clientGet) = 0;
</pre>

<p>The client must call</p>
<pre>
pvaClientGet->setRequester(shared_from_this());
</pre>
<p>
after creating an instance of PvaClientGet.
</p>
<h2>PvaClientPut</h2>
<h3>Brief Description</h3>
<p><b>PvaClientPut</b> has methods:</p>
<pre>
connect             Calls issueConnect and then waitConnect.
issueConnect        Issues a request to the server to create the server side of ChannelPut.
waitConnect         Blocks until server responds that it has created the ChannelPut.
get                 Calls issueGet and then waitGet.
issueGet            Issues a request to the server to get the latest data for a ChannelPut.
waitGet             Blocks until the server send a message that the get is complete.
put                 Calls issuePut and then waitPut.
issuePut            Issues a put request to the server.
waitPut             Blocks until the server sends a message that the put is complete.
getData             Get the PvaClientPutData.
setRequester        Set a pvaClientPutRequester.
getPvaClientChannel Get the PvaClientChannel.
</pre>

<p>
<b>NOTE:</b>
Except for union fields pvaClientPut takes care of modifying the bitSet associated with
the data sent to the server.
</p>
<p>An instance of PvaClientPut is created via a call to one of the followimg:</p>
<pre>
class PvaClientChannel
...
{
...
    PvaClientPutPtr put(std::string const &amp; request = "field(value,alarm,timeStamp)");
    PvaClientPutPtr createPut(std::string const &amp; request = "");
    PvaClientPutPtr createPut(epics::pvData::PVStructurePtr const &amp;  pvRequest);
...
};
</pre>

<h3>PvaClientPutRequester</h3>
<p>This is a virtual class that can be implemented by a client that uses <b>PvaClientPut</b>.
It has the methods:</p>
<pre>
virtual void channelPutConnect(
    const Status&amp; status,
    PvaClientPutPtr const &amp; clientPut) {}
virtual void getDone(
    const Status&amp; status,
    PvaClientPutPtr const &amp; clientPut) {}
virtual void putDone(
    const Status&amp; status,
    PvaClientPutPtr const &amp; clientPut) = 0;
</pre>

<p>The client must call</p>
<pre>
pvaClientPut->setRequester(shared_from_this());
</pre>
<p>
after creating an instance of PvaClientPut.
</p>


<h2>PvaClientMonitor</h2>
<h3>Brief Description</h3>
<p><b>PvaClientMonitor</b> has methods:</p>
<pre>
connect             Calls issueConnect and then waitConnect.
issueConnect        Issues a request to the server to create the server side of ChannelMonitor.
waitConnect         Blocks until server responds that it has created the ChannelMonitor.
start               Start monitoring.
stop                Stop monitoring.
poll                Poll for a monitor event. If return is true, call getData.
waitEvent           Wait for event.
releaseEvent        Release the monitorElement returned by poll.
getData             Get the PvaClientMonitorData.
setRequester        Set a pvaClientMonitorRequester.
getPvaClientChannel Get the PvaClientChannel.
</pre>
<p>An instance of PvaClientPut is created via a call to one of the followimg:</p>
<pre>
class PvaClientChannel
...
{
...
    PvaClientMonitorPtr monitor(std::string const &amp; request = "field(value,alarm,timeStamp)");
    PvaClientMonitorPtr monitor(PvaClientMonitorRequesterPtr const &amp; pvaClientMonitorRequester);
    PvaClientMonitorPtr monitor(
        std::string const &amp; request,
        PvaClientMonitorRequesterPtr const &amp; pvaClientMonitorRequester);
    PvaClientMonitorPtr createMonitor(std::string const &amp; request = "field(value,alarm,timeStamp)");
    PvaClientMonitorPtr createMonitor(epics::pvData::PVStructurePtr const &amp;  pvRequest);
...
};
</pre>
<h3>PvaClientMonitorRequester</h3>
<p>This is a virtual class that can be implemented by a client that uses <b>PvaClientMonitor</b>.
It has the methods:</p>
<pre>
virtual void monitorConnect(epics::pvData::Status const &amp; status,
        PvaClientMonitorPtr const &amp; monitor,
        epics::pvData::StructureConstPtr const &amp; structure);
virtual void event(PvaClientMonitorPtr const &amp; monitor) = 0;
virtual void unlisten();
</pre>

<h2>PvaClientProcess</h2>

<h3>Brief Description</h3>
<p><b>PvaClientProcess</b> has methods:</p>
<pre>
connect             Calls issueConnect and then waitConnect.
issueConnect        Issues a request to the server to create the server side of ChannelProcess.
waitConnect         Blocks until server responds that it has created the ChannelProcess.
process             Calls issueProcess and then waitProcess.
issueProcess        Issues a process request to the server.
waitProcess         Blocks until the server send a message that the process is complete.
setRequester        Set a pvaClientProcessRequester.
getPvaClientChannel Get the PvaClientChannel.
</pre>

<p>An instance of PvaClientProcess is created via a call to one of the followimg:</p>
<pre>
class PvaClientChannel
...
{
...
    PvaClientProcessPtr createProcess(std::string const &amp; request = "");
    PvaClientProcessPtr createProcess(epics::pvData::PVStructurePtr const &amp;  pvRequest);
...
};
</pre>
<h3>PvaClientProcessRequester</h3>
<p>This is a virtual class that can be implemented by a client that uses <b>PvaClientGet</b>.
It has the methods:</p>
<pre>
virtual void channelProcessConnect(
        const epics::pvData::Status&amp; status,
        PvaClientProcessPtr const &amp; clientProcess){}
virtual void processDone(
        const epics::pvData::Status&amp; status,
        PvaClientProcessPtr const &amp; clientProcess) = 0;
</pre>
<h2>PvaClientPutGet</h2>
<h3>Brief Description</h3>
<p><b>PvaClientPutGet</b> has methods:</p>
<pre>
connect             Calls issueConnect and then waitConnect.
issueConnect        Issues a request to the server to create the server side of ChannelPut.
waitConnect         Block until server responds that it has created the ChannelPut.
putGet              Call issuePutGet and then waitPutGet.
issuePutGet         Issue a putGet and return immediately.
waitPutGet          Block until putGet completes.
getGet              Calls issueGetGet and then waitGetGet.
issueGetGet         Issues a request to the server to get the latest data for the get data.
waitGetGet          Block until the server send a message that the getGet is complete.
getPut              Calls issueGetPut and then waitGetPut.
issueGetPut         Issues a request to the server to get the latest data for the put data.
waitGetPut          Block until the server send a message that the getPut is complete.
getPutData          Get PvaClientPutData
getGetData          Get PvaClientGetData
</pre>

<p>
<b>NOTE:</b>
Except for union fields pvaClientPutGet takes care of modifying the bitSet associated with
the data sent to the server.
</p>
<p>An instance of PvaClientPutGet is created via a call to one of the followimg:</p>
<pre>
class PvaClientChannel
...
{
...
    PvaClientPutGetPtr createPutGet(std::string const &amp; request);
    PvaClientPutGetPtr createPutGet(epics::pvData::PVStructurePtr const &amp;  pvRequest);
...
};
</pre>

<h3>PvaClientPutGetRequester</h3>
<p>This is a virtual class that can be implemented by a client that uses <b>PvaClientPut</b>.
It has the methods:</p>
<pre>
virtual void channelPutGetConnect(
    const Status&amp; status,
    PvaClientPutGetPtr const &amp; clientPutGet) {}
virtual void putGetDone(
    const Status&amp; status,
    PvaClientPutGetPtr const &amp; clientPutGet) {}
virtual void getPutDone(
    const Status&amp; status,
    PvaClientPutGetPtr const &amp; clientPutGet) = 0;
virtual void getGetDone(
    const Status&amp; status,
    PvaClientPutGetPtr const &amp; clientPutGet) = 0;
</pre>

<p>The client must call</p>
<pre>
pvaClientPutGet->setRequester(shared_from_this());
</pre>
<p>
after creating an instance of PvaClientPutGet.
</p>
<h2>PvaClientRPC</h2>
<h3>Brief Description</h3>
<p><b>PvaClientRPC</b> has methods:</p>
<pre>
create             called by PvaClientChannel::rpc or PvaClientChannel::createRPC
setResponseTimeout set timeout for waiting for a response
getResponseTimeout get response timeout
connect            call issueConnect and then waitConnect. exception if fail to connect        
issueConnect       issue a connect request
waitConnect        wait for connection
request            issue a request
</pre>
<p>An instance of PvaClientRPC is created via a call to one of the following:</p>
<pre>
class PvaClientChannel
...
{
...
    PvaClientRPCPtr createRPC();
    PvaClientRPCPtr createRPC(epics::pvData::PVStructurePtr const &amp;  pvRequest);
...
};
</pre>
<h3>PvaClientRPCRequester</h3>
<p>This is a virtual class that must be implemented by a client that uses <b>PvaClientRPC</b>.
It has the methods:</p>
<pre>
    virtual void requestDone(
        const epics::pvData::Status&amp; status,
        PvaClientRPCPtr const &amp; pvaClientRPC,
        epics::pvData::PVStructure::shared_pointer const &amp; pvResponse)()
</pre>

<h2>PvaClientMultiChannel Overview</h2>
<p>
<b>NOTE:</b>
Before reading this overview, clone and build
<a href="https://github.com/epics-base/exampleCPP">
exampleCPP
</a>.
This has examples that are referenced in this overview.
</p>
<p>This is support for getting, putting, and monitoring multiple channels.
Two kinds of support are available:
</p>
<dl>
  <dt>MultiDouble</dt>
  <dd>
  Support for channels that have a numeric scalar value field.
  </dd>
  <dt>NTMulti</dt>
  <dd>
  Support for channels that have a value field with each channel having diferent tyoes.
  </dd>
</dl>
<p><b>exampleCPP/pvaClientMultiChannel</b> has examples:</p>
<dl>
  <dt>multiPutGetDouble</dt>
     <dd>
     This supports get and put for a set of channels where each has a scalar value.
     </dd>
  <dt>multiMonitorDouble</dt>
     <dd>
     This supports monitor for  a set of channels where each has a scalar value.
     </dd>
  <dt>ntMultiPutGet</dt>
      <dd>
      This supports get and put for a set of channels where each has value with type scalar, scalarArray, or union.
      Note that is more complex than the <b>MultiDouble</b> example.
     </dd>
  <dt>ntMultiMonitor</dt>
     <dd>
     This supports a set of channels where each has value of any type.
     </dd>
</dl>
<p>
The following sections provide a brief summary of all methods provided by <b>pvaClient</b>
<br/>
Look at
<a
href="./html/index.html">doxygen
</a>
for details about each method,
</p>

<h2>pvaClientMultiChannel</h2>
<p>
<b>PvaMultiChannel</b> is a synchronous interface for accessing multiple channels.
</p>
 
<h3>PvaClientMultiChannel</h3>
<p><b>PvaClientMultiChannel</b> has methods:</p>
<pre>
create                   Create.
getChannelNames          Get the array of channel names.
connect                  For each channel, create and issueConnect.
                         Then for each channel waitConnect.
allConnected             Are all channels connected?
connectionChange         Is there a connection change since last call to getIsConnected?
getIsConnected           Get an array of the connection state of each channel.
getPvaClientChannelArray Get an array of pvaClientChannels.
getPvaClient             Get the pvaClint.      
createGet                Create a PvaClientMultiGetDouble.         
createNTGet              Create a PvaClientNTMultiGet.
createPut                Create a PvaClientMultiPut.
createNTPut              Create a PvaClientNTMultiPut.
createMonitor            Create a PvaClientMultiMonitorDouble.
createNTMonitor          Create a PvaClientNTMultiMonitor.
</pre>
<h3>PvaClientMultiGetDouble</h3>
<p><b>PvaClientMultiGetDouble</b> has methods:</p>
<pre>
connect Create a channelGet for each channel.
get     Get the data as a double array.
</pre>
<h3>PvaClientNTMultiGet</h3>
<p><b>PvaClientNTMultiGet</b> has methods:</p>
<pre>
connect Connect to each chanel.
get     Get the data from each channel.
getData get the data as PvaClientNTMultiData.
</pre>
<h3>PvaClientMultiPutDouble</h3>
<p><b>PvaClientMultiPutDouble</b> has methods:</p>
<pre>
connect    Create a channelPut for each channel.
put        Put the data via a double array
</pre>
<h3>PvaClientNTMultiPut</h3>
<p><b>PvaClientNTMultiPut</b> has methods:</p>
<pre>
connect   Create a channelPut for each channel.
getValues Get a PVUnion array that client uses to specify values for put.
put       Put the data for each channel.
</pre>
<h3>PvaClientMultiMonitorDouble</h3>
<p><b>PvaClientMultiMonitorDouble</b> has methods:</p>
<pre>
connect   Create a channelMonitor for each channel.
poll      Issue a poll request. Return (true,false) if new data available.
waitEvent Wait until poll returns true.
get       Get the data for the last poll as an array of double.
</pre>
<h3>PvaClientNTMultiMonitor</h3>
<p><b>PvaClientNTMultiMonitor</b> has methods:</p>
<pre>
connect   Create a channelMonitor for each channel.
poll      Issue a poll request. Return (true,false) if new data available.
waitEvent Wait until poll returns true.
getData   Get the data for the last poll as a PvaClientNTMultiData.
</pre>
<h3>PvaClientNTMultiData</h3>
<p><b>PvaClientNTMultiData</b> has methods:</p>
<pre>
getNTMultiChannel Get NTMultiChannel.
getNumber         Get the number of channels.
getTimeStamp      Get the timestamp when the last update was made.
</pre>

</div>
</body>
</html>

