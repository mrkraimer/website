<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS V4 Plugin Proposal</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>pvDatabase Plugin Support</h1>

<h2 class="nocount">2019.06.14</h2>
<dl>
  <dt>Editors:</dt>
    <dd>Marty Kraimer</dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>pvRequest Options</h2>
<p>
<b>NOTE:</b>
Plugin support via pvRequest is only implemented in C++ and only in:
<a href="https://github.com/epics-base/pvDatabaseCPP">pvDatabaseCPP</a>
</p>
<h3>Overview</h3>
<p>
Both record and field options can be specified.
This section provides some details about support for field options.
</p>
<p>Some examples are:</p>
<ul>
    <li>
       Get the subset of an array after making the record process.
<pre>
pvget -r "record[process=true]field(value[array=5:10])" someScalarArray
</pre>
     </li>
     <li>
      Monitor a record that has a numeric scalar value field<br />
      But only when value changes by at least 1.0 should a monitor occur.
      Changes in the timeStamp and alarm fields are ignored if no other fields being monitored
      change value.
<pre>
pvget -m -r "value[deadband=abs:1.0],timeStamp[ignore=true],alarm[ignore=true]" -v someScalar
</pre>
      </li>
</ul>

<h3>Field Plugin Filters</h3>
<p><b>pvCopy</b> implements plugin filters that can optionally
be attached to fields accessed via <b>pvCopy</b>.
Thus, if a  channel provider uses <b>pvCopy</b>, it automatically has plugin filter support.
</p>
<p>
<b>pvCopy</b> itself provides the following plugins: <b>array</b>, <b>deadband</b>,
<b>timestamp</b>, and <b>ignore</b>.
Other plugins can also be implemented and registered.
</p>
<p>
The following interfaces are used for implementing plugin filters:
<b>PVPlugin</b>, <b>PVFilter</b>, and <b>PVPluginRegistry</b>.
</p>
<h4>PVPlugin</h4>
<p>
Method <b>create</b> is called when an instance of <b>pvCopy</b> is created by a channel provider.
</p>
<pre>
interface PVPlugin {
    PVFilter create(String requestValue,PVCopy pvCopy,PVField master);
}
</pre>
where
<dl>
   <dt>requestValue</dt>
   <dd>
    The value part of a name=value request option.
   </dd>
   <dt>pvCopy</dt>
   <dd>
    The PVCopy to which the PVFilter will be attached.
   </dd>
   <dt>master</dt>
   <dd>
   The field in the master PVStructure to which the PVFilter will be attached.
   </dd>
</dl>
<p>
Returns the PVFilter. A null is returned if master or requestValue is not appropriate for the plugin.
</p>
<h4>PVFilter</h4>
<p>
The method <b>filter</b> is called whenever pvCopy is used to access a field of the client
PVStructure.
</p>
<pre>
interface PVFilter {
    boolean filter(PVField copy,BitSet bitSet,boolean toCopy);
    String getName();
}
</pre>
where
<dl>
   <dt>copy</dt>
   <dd>
    The data for copy.
   </dd>
   <dt>bitSet</dt>
   <dd>
    The BitSet for copy.
   </dd>
   <dt>toCopy</dt>
   <dd>
   (true,false) means copy (from master to copy,from copy to master)
   </dd>
</dl>
<p>
Returns (true,false) if filter modified destination.
</p>
<h4>PVPluginRegistry</h4>
<pre>
class PVPluginRegistry {
    static void registerPlugin(String name,PVPlugin pvPlugin);
    static PVPlugin find(String name);
}
</pre>
The arguments are:
<dl>
   <dt>name</dt>
   <dd>
    The name part of a name=value request option.
   </dd>
   <dt>pvPlugin</dt>
   <dd>
    The plugin implementation.
   </dd>
</dl>
<p>The return value for <b>find</b> is the plugin implementation or null if no plugin
with that name has been registered.
</p>
<h3>Array Plugin</h3>
<p>
This  filter is used to retrieve parts of an array (subarrays and strided subarrays).
It is modeled after the array Filter that is provided with epics base starting with
the 3.15 releases.
</p>
<p>
This filter works for both get and put.
It works for any scalarArray field.
It has not been tested for structureArray or unionArray fields.
</p>
<p>The syntax is one of the following:</p>
<pre>
[array=start]
[array=start:end]
[array=start:increment:end]
</pre>
<p>
<b>start</b> and <b>end</b> both specify an index.
<b>increment</b> must be a positive integer.
</p>
<p>
<b>start</b> and <b>end</b> can be a positive or negative integer.
If negative it is relative to the end of the array with -1 meaning the last element.
</p>
<p>Suppose that the master array is:</p>
<pre>
1,2,3,4,5,6,7,8,9,10
</pre>
<p>Then the get request</p>
<pre>
[array=0:4]
</pre>
gets
<pre>
1,2,3,4,5
</pre>
The request:
<pre>
[array=-3:-1]
</pre>
gets
<pre>
8,9,10
</pre>
The request:
<pre>
[array=2:5]
</pre>
gets
<pre>
3,4,5,6
</pre>
The request:
<pre>
[array=0:2:-1]
</pre>
gets
<pre>
0,2,4,6,8,10
</pre>
<h3>Deadband Plugin</h3>
<p>
This filter is used to limit the changes to a numeric scalar field that are reported to a client. 
It is modeled after the deadband Filter that is provided with epics base starting with
the 3.15 releases.
</p>
<p>
This filter only works for numeric scalar fields and only for toCopy.
</p>
<p>The syntax is one of the following:</p>
<pre>
[deadband=abs:value]
[deadband=rel:value]
</pre>
where
<dl>
   <dt>abs</dt>
    <dd>The value must change by at least this amount since the last value the client received.</dd>
   <dt>rel</dt>
     <dd>
       The percentage amount the value must change since the last value the client received. 
     </dd>
</dl>
<h3>Proposed New Options</h3>
<p>The following options could be added:
</p>
<pre>
[deadband=skip:value]
[deadband=maxrate:value]
[deadband=maxvalue:value]
[deadband=minvalue:value]
</pre>
where
<dl>
   <dt>skip</dt>
     <dd>
      value is the number of changes to ignore between declaring an event.
     </dd>
   <dt>maxrate</dt>
     <dd>
      value is the maximum rate in seconds to declare events.
     </dd>
   <dt>maxvalue</dt>
     <dd>
      only values less than or equal to value cause an event.
     </dd>
   <dt>minvalue</dt>
     <dd>
      only values greater than or equal to value cause an event.
     </dd>
</dl>
<h3>TimeStamp Plugin</h3>
<p>
This filter is used for accessing a timeStamp field. 
It is modeled after the timeStamp Filter that is provided with epics base starting with
the 3.15 releases.
</p>
<p>
This filter only works for a timeStamp field.
</p>
<p>The syntax is one of the following:</p>
<pre>
[timestamp=current]
[timestamp=copy]
</pre>
where
<dl>
  <dt>current</dt>
     <dd>
      Only works for toCopy=true.
      Instead of taking the timestamp from master the timeStamp for the client is set to
      the current time.
     </dd>
   <dt>copy</dt>
     <dd>
      Only works for toCopy=false.
      The timestamp in master is set equal to the timeStamp from the client.
     </dd>
</dl>
<h3>Ignore Plugin</h3>
<p>This is not an actual plugin but is handled by pvCopy itself.
It is used to suppress sending data to a client unless other fields have changed.
</p>
<p>The syntax is:</p>
<pre>
[ignore=true]
</pre>
One of the examples shown at the beginning of this section shows how it can be used.
<h2>Examples</h2>
<p>
<b>UNDER DEVELOPMENT</b>
Note that following link is in S<b>mrkraimer</b> instead of <b>epics-base</b>.
</p>
<p>
<a
href="https://github.com/mrkraimer/exampleCPP">exampleCPP
</a>
Contains <b>exampleCPP/plugin</b>, which contains examples that use plugins.
</p>
<h3>Initialize</h3>
<h4>Start database</h4>
<p>After building exampleCPP, start the database for the plugin examples as follows:
</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/plugin/iocBoot/plugin
mrk> ../../bin/linux-x86_64/plugin st.cmd 
...
iocRun: All initialization complete
traceRecordCreate PVRpluginTraceRecord
removeRecordCreate PVRpluginRemoveRecord
processRecordCreate PVRpluginProcessRecord .5
pluginRecordCreate PVRpluginDouble
pluginRecordCreate PVRpluginUByte pvUByte
scalarArrayRecordCreate PVRscalarArrayDouble
scalarArrayRecordCreate PVRscalarArrayUByte pvUByte
scalarArrayRecordCreate PVRscalarArrayString pvString
scalarArrayRecordCreate PVRscalarArrayBoolean pvBoolean
epics> 
</pre>
Note that amoung the PVRecords sre:
<dl>
  <dt>PVRpluginDouble</dt>
   <dd>
    A record which has fields appropriate for use by the plugin example described below.
    The value field has ScalarType pvDouble.
   </dd>
  <dt>PVRpluginUByte</dt>
   <dd>
    Like PVRpluginDouble except that the value field has ScalarType pvUByte.
   </dd>
  <dt>PVRscalarArrayDouble</dt>
   <dd>
    This is for testing the array plugin.
   </dd>
  <dt>PVRscalarArrayUbyte</dt>
   <dd>
    This is for testing the array plugin.
   </dd>
  <dt>PVRscalarArrayString</dt>
   <dd>
    This is for testing the array plugin.
   </dd>
  <dt>PVRscalarArrayBoolean</dt>
   <dd>
    This is for testing the array plugin.
   </dd>
  <dt>PVRpluginProcessRecord</dt>
   <dd>
    This is a record that has a thread that processes other records at a specified rate.
    Below there is a script to add or remove records to be processed.
   </dd>
</dl>
<h4>Start Clients</h4>
<p>Run the following:</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/plugin/testClient/scripts
mrk> ./configAll 
...
</pre>
<p>configAll does the following:</p>
<ul>
   <li>
    Sets control and scalarAlarm fields for both PVRpluginDouble and PVRpluginUByte.
   </li>
   <li>
    Adds both PVRpluginDouble and PVRpluginUByte to PVRpluginProcessRecord
   </li>
</ul>
<h4>Run an example client</h4>
<p>Start the following:</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/plugin/testClient/scripts
[1]+  Done                    gedit -s exampleDeadband
mrk> ./exampleDeadband
recordName?
PVRpluginDouble
deadband?
abs:1
</pre>
<p>You should see lots of monitors and also see control limits enforced and see
alarms changing as determined by scalarAlarm settings.
</p>
<h4>Run an example that uses the array plugin</h4>
<pre>
./exampleArray
</pre>
<h3>scripts</h3>
<p>The scripts all appear in:
</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/plugin/testClient/scripts
</pre>
<p>The scripts with names that start with config or clear can be run either interactively
or via arguments.
The only exception is <b>configAll</b>
</p>
<h4>configAll</h4>
<p>Use of this was shown above.</p>
<h4>exampleDeadband</h4>
<p>
Runs an example using deadbands.
</p>
<h4>exampleArray</h4>
<p>
Runs an example showing array plugin.
</p>
<h4>configControl</h4>
<p>
An example usage is:
</p>
<pre>
mrk> ./configControl
recordName?
PVRpluginDouble
limitLow
-10
limitHigh
10
minStep
.5
Old : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2.5
New : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2.5
mrk> 
</pre>
<p>It could do the same without prompts via:
</p>
<pre>
mrk> ./configControl PVRpluginDouble -10 10 .5
Old : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2
New : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double mrk> ./configControl PVRpluginDouble -10 10 .5
Old : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2
New : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2
mrk> 
 0.5
        double outputValue 2
mrk> 
</pre>
<p>The same could be done using pvput as follows:
</p>
<pre>
mrk> pvput -r "control" PVRpluginDouble control='{"limitLow":"-10","limitHigh":"10","minStep":".5"}'
</pre>
<h4>clearControl</h4>
<p>Sets all control fields so no control limits are present.
</p>
<h4>configScalarAlarm</h4>
<p>
An example usage is:
</p>
<pre>
mrk> ./configScalarAlarm
recordName?
PVRpluginDouble
active
true
lowAlarmLimit
-8
lowWarningLimit
-6
highWarningLimit
6
highAlarmLimit
8
hysteresis
.1
Old : structure 
    scalarAlarm_t scalarAlarm
        boolean active true
        double lowAlarmLimit -8
        double lowWarningLimit -6
        double highWarningLimit 6
        double highAlarmLimit 8
        double hysteresis 0.1
New : structure 
    scalarAlarm_t scalarAlarm
        boolean active true
        double lowAlarmLimit -8
        double lowWarningLimit -6
        double highWarningLimit 6
        double highAlarmLimit 8
        double hysteresis 0.1
mrk> 
</pre>
<p>
Just like configControl it can be invoked by giving all values as arguments.
</p>
<h4>clearScalarAlarm</h4>
<p>Clears all the scalarAlarm fields.</p>
<h4>configProcessRecord</h4>
<p>example usage is:
</p>
<pre>
mrk> ./configProcessRecord
processRecordName
PVRpluginProcessRecord
command?
remove
recordName
PVRpluginDouble
// result is
PVRpluginProcessRecord
argument={"command":"remove","recordName":"PVRpluginDouble"}
Old : structure 
    structure argument
        string command add
        string recordName PVRpluginDouble
    structure result
        string status PVRpluginDouble already pesent
New : structure 
    structure argument
        string command remove
        string recordName PVRpluginDouble
    structure result
        string status success
mrk> 
</pre>
<p>It can also be invoked with arguments.</p>
<p>
The same can be done via:
</p>
<pre>
mrk> pvput -r "argument" PVRpluginProcessRecord argument='{"command":"add","recordName":"PVRpluginDouble"}'
Old : structure 
    structure argument
        string command remove
        string recordName PVRpluginDouble
New : structure 
    structure argument
        string command add
        string recordName PVRpluginDouble
</pre>
<h4>controlSigned</h4>
<p>
Convenience script for signed control limits.
</p>
<h4>controlUnsigned</h4>
<p>
Convenience script for unsigned control limits.
</p>
<h4>scalarAlarmSigned</h4>
<p>
Convenience script for signed scalarAlarm limits.
</p>
<h4>scalarAlarmUnsigned</h4>
<p>
Convenience script for unsigned scalarAlarm limits.
</p>

<h2>Appendix I: ignore semantics</h2>
<p>Plugin ignore is not a separate plugin, but is implemented by pvCopy itself.
This is because it needs to implement the following semantics:
</p>
<p style="margin-left: 40px">
If only fields with option <b>ignore=true</b> have been changed than no event is declared.
But the next time any other field changes then all such fields that did get changed
will also be part of the event data.
</p>
<p>The channel provider for PVDatabase calls the following for channelGet:
</p>
<pre>
notifyClient = pvCopy->updateCopySetBitSet
</pre>
<p>The channel provider for PVDatabase calls the following for monitor
</p>
<pre>
bool result = pvCopy->updateCopyFromBitSet
</pre>
Both update methods  end with the statement:
<pre>
return checkIgnore(copyPVStructure,bitSet);
</pre>
This code is:
<pre>
bool PVCopy::checkIgnore(
     PVStructurePtr const &amp; copyPVStructure,
     BitSetPtr const &amp; bitSet)
{
    if(!ignorechangeBitSet) {
        return (bitSet->nextSetBit(0)&lt;0) ? false : true;
    }
    int32 numFields = copyPVStructure->getNumberFields();
    BitSet temp(numFields);
    temp = *bitSet;
    int32 ind = 0;
    while(true) {
        ind = ignorechangeBitSet->nextSetBit(ind);
        if(ind&lt;0) break;
        temp.clear(ind);
        ind++;
        if(ind>=numFields) break;
    }
    return (temp.nextSetBit(0)&lt;0) ? false : true;
}
</pre>
<p>
Note that the code:
</p>
<ul>
  <li>
   Creates a temporary bitSet that is initialized to the current bitSet.
  </li>
  <li>
   Looks at all fields specified by <b>ignorechangeBitSet</b>
   and turns off the corresponding bit in the temporary bit set.
  </li>
  <li>
   Returns (true,false) if the temporary bit set is  (not, is) empty.
  </li>
  <li>
   The current bitSet is not modified. Thus the next time the bitSet has it's old value.
  </li>
</ul>
</div>
</body>
</html>
