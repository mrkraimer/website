<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>pvDatabase Plugin Support</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>pvDatabase Plugin Support</h1>

<h2 class="nocount">editions</h2>
<dl>
  <dt>2019.06.21</dt>
     <dd>Original</dd>
  <dt>2021.04.04</dt>
     <dd>Update</dd>
</dl>  
<dl>
  <dt>Editors:</dt>
    <dd>Marty Kraimer</dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>PVDatabase Plugin Support</h2>
<p>
<b>NOTE:</b>
Plugin support via pvRequest is only implemented in C++ and only in:
<a href="https://github.com/epics-base/pvDatabaseCPP">pvDatabaseCPP</a>
</p>
<h3>Overview</h3>
<p>
Both record and field options can be specified.
This section provides some details about support for field options.
</p>
<p>Some examples are:</p>
<ul>
    <li>
       Get the subset of an array after making the record process.
<pre>
pvget -r "record[process=true]field(value[array=5:10])" someScalarArray
</pre>
     </li>
     <li>
      Monitor a record that has a numeric scalar value field<br />
      But only when value changes by at least 1.0 should a monitor occur.
      Changes in the timeStamp and alarm fields are ignored if no other fields being monitored
      change value.
<pre>
pvget -m -r "value[deadband=abs:1.0],timeStamp[ignore=true],alarm[ignore=true]" -v someScalar
</pre>
      </li>
</ul>

<h3>Field Plugin Filters</h3>
<p><b>pvCopy</b> implements plugin filters that can optionally
be attached to fields accessed via <b>pvCopy</b>.
Thus, if a  channel provider uses <b>pvCopy</b>, it automatically has plugin filter support.
</p>
<p>
<b>pvCopy</b> itself provides the following plugins: <b>array</b>, <b>deadband</b>,
<b>timestamp</b>, and <b>ignore</b>.
Other plugins can also be implemented and registered.
</p>
<p>
The following interfaces are used for implementing plugin filters:
<b>PVPlugin</b>, <b>PVFilter</b>, and <b>PVPluginRegistry</b>.
</p>
<h4>PVPlugin</h4>
<p>
Method <b>create</b> is called when an instance of <b>pvCopy</b> is created by a channel provider.
</p>
<pre>
interface PVPlugin {
    PVFilter create(String requestValue,PVCopy pvCopy,PVField master);
}
</pre>
where
<dl>
   <dt>requestValue</dt>
   <dd>
    The value part of a name=value request option.
   </dd>
   <dt>pvCopy</dt>
   <dd>
    The PVCopy to which the PVFilter will be attached.
   </dd>
   <dt>master</dt>
   <dd>
   The field in the master PVStructure to which the PVFilter will be attached.
   </dd>
</dl>
<p>
Returns the PVFilter. A null is returned if master or requestValue is not appropriate for the plugin.
</p>
<h4>PVFilter</h4>
<p>
The method <b>filter</b> is called whenever pvCopy is used to access a field of the client
PVStructure.
</p>
<pre>
interface PVFilter {
    boolean filter(PVField copy,BitSet bitSet,boolean toCopy);
    String getName();
}
</pre>
where
<dl>
   <dt>copy</dt>
   <dd>
    The data for copy.
   </dd>
   <dt>bitSet</dt>
   <dd>
    The BitSet for copy.
   </dd>
   <dt>toCopy</dt>
   <dd>
   (true,false) means copy (from master to copy,from copy to master)
   </dd>
</dl>
<p>
Returns (true,false) if filter modified destination.
</p>
<h4>PVPluginRegistry</h4>
<pre>
class PVPluginRegistry {
    static void registerPlugin(String name,PVPlugin pvPlugin);
    static PVPlugin find(String name);
}
</pre>
The arguments are:
<dl>
   <dt>name</dt>
   <dd>
    The name part of a name=value request option.
   </dd>
   <dt>pvPlugin</dt>
   <dd>
    The plugin implementation.
   </dd>
</dl>
<p>The return value for <b>find</b> is the plugin implementation or null if no plugin
with that name has been registered.
</p>
<h3>Array Plugin</h3>
<p>
This  filter is used to retrieve parts of an array (subarrays and strided subarrays).
It is modeled after the array Filter that is provided with epics base starting with
the 3.15 releases.
</p>
<p>
This filter works for both get and put.
It works for any scalarArray field.
It has not been tested for structureArray or unionArray fields.
</p>
<p>The syntax is one of the following:</p>
<pre>
[array=start]
[array=start:end]
[array=start:increment:end]
</pre>
<p>
<b>start</b> and <b>end</b> both specify an index.
<b>increment</b> must be a positive integer.
</p>
<p>
<b>start</b> and <b>end</b> can be a positive or negative integer.
If negative it is relative to the end of the array with -1 meaning the last element.
</p>
<p>Suppose that the master array is:</p>
<pre>
1,2,3,4,5,6,7,8,9,10
</pre>
<p>Then the get request</p>
<pre>
[array=0:4]
</pre>
gets
<pre>
1,2,3,4,5
</pre>
The request:
<pre>
[array=-3:-1]
</pre>
gets
<pre>
8,9,10
</pre>
The request:
<pre>
[array=2:5]
</pre>
gets
<pre>
3,4,5,6
</pre>
The request:
<pre>
[array=0:2:-1]
</pre>
gets
<pre>
0,2,4,6,8,10
</pre>
<h3>Deadband Plugin</h3>
<p>
This filter is used to limit the changes to a numeric scalar field that are reported to a client. 
It is modeled after the deadband Filter that is provided with epics base starting with
the 3.15 releases.
</p>
<p>
This filter only works for numeric scalar fields and only for toCopy.
</p>
<p>The syntax is one of the following:</p>
<pre>
[deadband=abs:value]
[deadband=rel:value]
</pre>
where
<dl>
   <dt>abs</dt>
    <dd>The value must change by at least this amount since the last value the client received.</dd>
   <dt>rel</dt>
     <dd>
       The percentage amount the value must change since the last value the client received. 
     </dd>
</dl>
<h3>Proposed New Options</h3>
<p>The following options could be added:
</p>
<pre>
[deadband=skip:value]
[deadband=maxrate:value]
[deadband=maxvalue:value]
[deadband=minvalue:value]
</pre>
where
<dl>
   <dt>skip</dt>
     <dd>
      value is the number of changes to ignore between declaring an event.
     </dd>
   <dt>maxrate</dt>
     <dd>
      value is the maximum rate in seconds to declare events.
     </dd>
   <dt>maxvalue</dt>
     <dd>
      only values less than or equal to value cause an event.
     </dd>
   <dt>minvalue</dt>
     <dd>
      only values greater than or equal to value cause an event.
     </dd>
</dl>
<h3>TimeStamp Plugin</h3>
<p>
This filter is used for accessing a timeStamp field. 
It is modeled after the timeStamp Filter that is provided with epics base starting with
the 3.15 releases.
</p>
<p>
This filter only works for a timeStamp field.
</p>
<p>The syntax is one of the following:</p>
<pre>
[timestamp=current]
[timestamp=copy]
</pre>
where
<dl>
  <dt>current</dt>
     <dd>
      Only works for toCopy=true.
      Instead of taking the timestamp from master the timeStamp for the client is set to
      the current time.
     </dd>
   <dt>copy</dt>
     <dd>
      Only works for toCopy=false.
      The timestamp in master is set equal to the timeStamp from the client.
     </dd>
</dl>
<h3>Ignore Plugin</h3>
<p>This is not an actual plugin but is handled by pvCopy itself.
It is used to suppress sending data to a client unless other fields have changed.
</p>
<p>The syntax is:</p>
<pre>
[ignore=true]
</pre>
One of the examples shown at the beginning of this section shows how it can be used.
<h2>Examples</h2>

<h3>array</h3>
<p>
To see the array plugin in action.
</p>
<pre>
pvput PVRdoubleArray value=[1,2,3,4,5,6,7,8,9,10]
...
</pre>
<br/>
then
<pre>
pvget -r "value[array=1:2:9]" PVRdoubleArray
PVRdoubleArray [2,4,6,8,10]
</pre>
then
<pre>
pvput -r "value[array=1:2:9]" PVRdoubleArray [100,200,300,400,500]
...
</pre>
then
<pre>
pvget -r value PVRdoubleArray
PVRdoubleArray [1,100,3,200,5,300,7,400,9,500]
</pre>
<p>
<b>NOTE:</b>
The syntax for setting value, i. e.</p>
<pre>
value='[10,20,30]'
</pre>
Also could be:
<pre>
value='["10","20","30"]'
</pre>
In fact if the element values are anything except an integer,
each element should be enclosed in quotes.
<h3>deadband and ignore</h3>
<p>In one window:</p>
<pre>
pvget -m -v -r "timeStamp[ignore=true],alarm[ignore=true],value[deadband=abs:1]" PVRdouble
</pre>
<p>Then in another window:</p>
<pre>
pvput PVRdouble 10
pvput PVRdouble 9.5
pvput PVRdouble 9
pvput PVRdouble 8.5
pvput PVRdouble 5
</pre>

<h2>Appendix I: ignore semantics</h2>
<p>Plugin ignore is not a separate plugin, but is implemented by pvCopy itself.
This is because it needs to implement the following semantics:
</p>
<p style="margin-left: 40px">
If only fields with option <b>ignore=true</b> have been changed than no event is declared.
But the next time any other field changes then all such fields that did get changed
will also be part of the event data.
</p>
<p>The channel provider for PVDatabase calls the following for channelGet:
</p>
<pre>
notifyClient = pvCopy->updateCopySetBitSet
</pre>
<p>The channel provider for PVDatabase calls the following for monitor
</p>
<pre>
bool result = pvCopy->updateCopyFromBitSet
</pre>
Both update methods  end with the statement:
<pre>
return checkIgnore(copyPVStructure,bitSet);
</pre>
This code is:
<pre>
bool PVCopy::checkIgnore(
     PVStructurePtr const &amp; copyPVStructure,
     BitSetPtr const &amp; bitSet)
{
    if(!ignorechangeBitSet) {
        return (bitSet->nextSetBit(0)&lt;0) ? false : true;
    }
    int32 numFields = copyPVStructure->getNumberFields();
    BitSet temp(numFields);
    temp = *bitSet;
    int32 ind = 0;
    while(true) {
        ind = ignorechangeBitSet->nextSetBit(ind);
        if(ind&lt;0) break;
        temp.clear(ind);
        ind++;
        if(ind>=numFields) break;
    }
    return (temp.nextSetBit(0)&lt;0) ? false : true;
}
</pre>
<p>
Note that the code:
</p>
<ul>
  <li>
   Creates a temporary bitSet that is initialized to the current bitSet.
  </li>
  <li>
   Looks at all fields specified by <b>ignorechangeBitSet</b>
   and turns off the corresponding bit in the temporary bit set.
  </li>
  <li>
   Returns (true,false) if the temporary bit set is  (not, is) empty.
  </li>
  <li>
   The current bitSet is not modified. Thus the next time the bitSet has it's old value.
  </li>
</ul>
</div>
</body>
</html>
