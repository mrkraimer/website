<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>pvaClient JSON support</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>pvaClient JSON support</h1>

<h2 class="nocount">2019.08.01</h2>
<dl>
  <dt>Editors:</dt>
    <dd>Marty Kraimer</dd>
</dl>
<p>
<b>NOTES:</b>
</p>
<ul>
  <li>The following requires both pvaClientCPP and exampleCPP.
    What is described is not part of any EPICS Release up to and including <b>EPICS 7.0.3</b>
    <br />
    For now the versions in the 
    must be cloned from the following github repositories:
    <br />
<a href = "https://github.com/epics-base/pvaClientCPP">pvaClientCPP
</a>
and
<a href = "https://github.com/epics-base/exampleCPP">exampleCPP
</a>
  </li>
  <li>
     Only the C++ implementation is available.
  </li>
  <li>
    The epics base version must be 3.15 or later.
  </li>
</ul>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Overview</h2>
<h3>Background</h3>
<p>This document provides a description of the JSON support provided by pvaClientCPP.
The put support is modeled on the JSON syntax for
<b>pvput</b>.
The get support is modeled on the JSON syntax for
<b>pvget</b>
</p>
<p>
The following are some examples:
</p>
<pre>
mrk> pvput PVRdouble '{"value":"10"}'
Old : &lt;undefined&gt;              0 
New : 2019-07-18 13:23:52.973  10 
mrk> pvput PVRdouble value=10.5
Old : 2019-07-22 10:02:40.140 10 
New : 2019-07-22 14:20:47.197  20 10.5 
mrk> pvput PVRdoubleArray '{"value":["10","20"]}'
Old : &lt;undefined&gt;              []
New : 2019-07-18 13:24:01.187  [10,20]
mrk> pvput -r "value,alarm"  PVRdouble '{"alarm":{"severity":"1","status":"2","message":"I did this"}}'
Old : 10 
New : 10 MINOR DRIVER I did this
mrk> pvget -M json -r "value,alarm" PVRlong
PVRlong {"value": 0,"alarm": {"severity": 0,"status": 0,"message": ""}}
</pre>
<h3>JSON syntax brief description</h3>
<p>
The following is a brief description of the JSON syntax for pvData.
See <a href="https://json.org">json</a> for a more complete description.
</p>
<p>A PVStructure is represented by:
</p>
<pre>
{...} 
</pre> 
where <b>...</b> is a comma separated set of name,value pairs;
One pair for each subfield in the PVStructure.    
<p>The name,value pair for each each PVData field is:
</p>
<pre>
"name":&lt;value&gt;
</pre>
where
<b>name</b> is the PVField name.
and <b>&lt;value&gt;</b> is :
<pre>
"value"    // field must be scalar. value is the field value.
or
value      // field must be numeric scalar
or
true       // field must be boolean
or
false      // field must be boolean
or
[&lt;value&gt;,&lt;value&gt;...]  // field must be a scalarArray 
or
{...}     // field must be a structure
</pre>

<p>
The JSON support implemented by pvaClientCPP uses similar syntax.
This is what is described in this document.
</p>

<p>Some examples are:</p>
<pre>
pvput PVRstring '{"value":"this is a string"}'
pvput PVRdouble '{"value":"10"}'
pvput PVRdouble '{"value":2.3}'
pvput PVRboolean '{"value":"true"}'
pvput PVRboolean '{"value":false}'
pvput PVRdoubleArray '{"value":[1.2,4,9.34]}'
pvput -r "value,timeStamp" PVRdouble '{"value":10,"timeStamp":{"userTag":20}}'
</pre>

<h2>Theory Of Operation</h2>

<h3>epics-base json</h3>
<p>
Starting with the 3.15 releases of epics base,
a JSON parser is provided.
</p>
<p>
For this document it is not necessary to describe the parser
other than to say that
it is required because it is used by pvDataCPP.
</p>
<h3>pvDataCPP json</h3>
<p>
pvDataCPP provides JSON support for pvData objects.
The user interface is described in <b>json.h</b>.
One of the methods is:
</p>
<pre>
void parseJSON(std::istream&amp; strm,
               PVField&amp; dest,
               BitSet *assigned=0);
</pre>
<p>
For a PVField it provides the following:
</p>
<dl>
   <dt>scalar</dt>
     <dd>
     All the scalar types are supported.
     <dl>
       <dt>boolean</dt>
        <dd>
         value can be <b>true</b> or <b>false</b>
        </dd>
       <dt>integer</dt>
        <dd>
        signed and unsigned integers of length  8, 16, 32, and 64 bits are supported.
        </dd>
       <dt>float</dt>
        <dd>
          IEEE 32 bit floating point.
        </dd>
       <dt>double</dt>
        <dd>
          IEEE 64 bit floating point.
        </dd> 
       <dt>string</dt>
        <dd>
         std::string
        </dd> 
     </dl>
     </dd>
   <dt>scalarArray</dt>
     <dd>
     Supported for all scalar types.
     <br />
     <b>Note:</b> new values are appended to existing values.
     </dd>
   <dt>structure</dt>
     <dd>
     Support for all fields that have type scalar, scalarArray, or structure.
     </dd>
   <dt>union</dt>
     <dd>
      No support.
     </dd>
   <dt>structureArray</dt>
     <dd>
     No support.
     </dd>
   <dt>unionArray</dt>
     <dd>
     No support.
     </dd>
</dl>
<p>Another method is:
</p>
<pre>
void printJSON(std::ostream&amp; strm,
               const PVStructure&amp; val,
               const BitSet&amp; mask,
               const JSONPrintOptions&amp; opts = JSONPrintOptions());
</pre>
<p>pvaClientCPP uses this method.</p>

<h3>pvaClientCPP json</h3>
<p>
One of the classes implemented by pvaClientCPP is <b>PvaClientData</b>,
which has the following methods:
</p>
<pre>
void parse(const std::vector&lt;std::string&gt; &amp;args);
void streamJSON(
               std::ostream&amp; strm,
               bool ignoreUnprintable = true,
               bool multiLine = false);
void zeroArrayLength();
</pre>
where
<dl>
   <dt>parse</dt>
     <dd>
        This is used to change fields in the pvStructure in PvaClientData.
     </dd>
   <dt>streamJSON</dt>
      <dd>
       This produces JSON syntax for the data in pvStructure.
      </dd>
   <dt>zeroArrayLength</dt>
      <dd>
      parseJSON shown above appends scalarArray values to the current value.
      This is usually not what the client wants.
      This can be called before calling parse.
      <br />
      This should NOT be called if parse is being called with the special enumerated
      syntax shown below.
      </dd>
</dl>
<p>Since <b>PvaClientData</b> is the base data class for channelGet,
channelPut, channelPutGet, and channelMonitor, it is available for use by each.
The example shown below uses it for channelPut and channelPutGet.
</p>
<h4>Syntax for parse</h4>
<p>
<b>NOTE:</b>
In the following <b>json</b> means JSON syntax.
The other syntax is provided by <b>parse</b>.
</p>
<p>
Each argument provides data for fields in the current PVStructure.
The syntax for each argument is one of the following:
</p>
<pre>
json
or
field=json
or
field=value           // enumerated
or
field=value=type=json // restricted union
</pre>
<dl>
   <dt>json</dt>
    <dd>
     This means pure json syntax as defined by pvDataCPP.
     An example is:
<pre>
parsePut PVRdouble '{"value":"10"}'
</pre>
    </dd>
   <dt>field=json</dt>
    <dd>
     field must be <b>name.name..</b>. It selects a subfield
     of the PVStructure. If the subfield does not exist an exception 
     is thrown.
     The json syntax is for the selected subfield.
     An example is:
<pre>
parsePut PVRBigRecord scalar.string.value='"this is a string"'
</pre>
    </dd>
   <dt>field=value</dt>
    <dd>
     This is a special case for an enumerated structure.
     The value specifies a valid choice.
      The index is what changes.
     An example is:
<pre>
 parsePut -z false PVRenum value=one
</pre>
    </dd>
   <dt>field=value=type=json</dt>
    <dd>
     field must select a restricted union field.
     type selects the restriced union type.
     An instance is created and the json syntax writes to the new instance.
     <br />
     Note that if type again selects a restricted union recursion is supported.
     For example <b>field=value=type=type=json</b>
    Examples are:
<pre>
parsePut PVRrestrictedUnion value='string="test string"'
parsePut PVRrestrictedUnion value='union_t=point={"x":".1","y":".2"}'
</pre>
    </dd>
</dl>   
<h2>exampleCPP/json</h2>
<p>
This contains examples that use the JSON methods provided with PvaClientData.
</p>
<h3>command line tools</h3>
<h4>parsePut</h4>
<p>
This is a command that allows a client to perform a channelPut,
with JSON format arguments.
<br />
The command provides:
</p>
<pre>
parsePut -help
 -h -p provider -r request  -z zeroarray - d debug channelName args 
</pre>

<p>
The source contains the following code:
</p>
<pre>
PvaClientPtr pva= PvaClient::get(provider);
PvaClientChannelPtr channel = pva->channel(channelName,provider,2.0);
PvaClientPutPtr put = channel->put(request);
PvaClientPutDataPtr putData(put->getData());
if(zeroarray) putData->zeroArrayLength();
putData->getChangedBitSet()->clear();
putData->parse(args);
put->put();
</pre>
<p>
Examples are shown below.
</p>
<h4>parsePutGet</h4>
<p>
This is similar to parsePut except that it uses channelPutGet.
</p>
<h4>jsonGet</h4>
<p>This is a command that display data obtained via channelGet with JSON syntax.
<br/>
The command provides:
</p>
<pre>
jsonGet -help
 -h -p provider -r request -m multiline - d debug channelName 
</pre>
<p>An example is:
</p>
<pre>
jsonGet -r "value,alarm" PVRstring
_____jsonGet channel PVRstring provider pva request value,alarm multiline false debug false
{"value": "three","alarm": {"severity": 0,"status": 0,"message": ""}}
</pre>
<p>
The source contains the following code:
</p>
<pre>
PvaClientPtr pva(PvaClient::get(provider));
PvaClientGetDataPtr pvData =
    pva->channel(channelName,provider,2.0)->get(request)->getData();
std::ostringstream os;
pvData->streamJSON(os,true,multiline);
cout &lt;&lt; os.str() &lt;&lt; "\n";
</pre>
<h3>client scripts</h3>
<p>
<b>json/client/scripts</b>
has examples that use the command line tools.
</p>
<h2>Running the examples</h2>
<h3>Start the IOC for the examples</h3>
<p>
In a window start the IOC:
</p>
<pre>
mrk> pwd
/home/epicsv4/masterCPP/exampleCPP/database/iocBoot/exampleDatabase
mrk> ../../bin/linux-x86_64/exampleDatabase st.cmd 
...
epics> 
</pre>
<h3>exampleCPP/json/client/scripts/exampleScalar</h3>
<p>This contains;</p>
<pre>
#!/bin/sh
source ./setEnv
${PARSE}/parsePut -r "value" PVRdouble value=1
sleep .5
${PARSE}/parsePut -r "value" PVRdouble '{"value":2}'
sleep .5
${PARSE}/parsePutGet -r "putField(value)getField(value)" PVRdouble value=10
sleep .5
${PARSE}/parsePut -r "value" PVRstring value='"one"'
sleep .5
${PARSE}/parsePut -r "value" PVRstring '{"value":"two"}'
sleep .5
${PARSE}/parsePutGet -r "putField(value)getField(value)" PVRstring value='"three"'
sleep .5
${PARSE}/parsePut  -r "value" PVRboolean value=true
sleep .5
${PARSE}/parsePut  -r "value" PVRboolean '{"value":false}'
sleep .5
${PARSE}/parsePutGet -r "putField(value)getField(value)" PVRboolean value=true
sleep .5
${PARSE}/parsePut -r "value" DBRdouble value=1
sleep .5
${PARSE}/parsePut -r "value" -p ca DBRdouble value=5
sleep .5
${PARSE}/parsePut -r "value" DBRstring00 value='"one"'
sleep .5
${PARSE}/parsePut -r "value" -p ca DBRstring00 value='"two"'
</pre>
<p>Running it produces:
</p>
<pre>
./exampleScalar
_____parsePut channel PVRdouble provider pva request value zeroarray true debug false
_____parsePut channel PVRdouble provider pva request value zeroarray true debug false
_____parsePutGet channel PVRdouble provider pva request putField(value)getField(value) zeroarray true debug false
structure 
    double value 10

_____parsePut channel PVRstring provider pva request value zeroarray true debug false
_____parsePut channel PVRstring provider pva request value zeroarray true debug false
_____parsePutGet channel PVRstring provider pva request putField(value)getField(value) zeroarray true debug false
structure 
    string value three

_____parsePut channel PVRboolean provider pva request value zeroarray true debug false
_____parsePut channel PVRboolean provider pva request value zeroarray true debug false
_____parsePutGet channel PVRboolean provider pva request putField(value)getField(value) zeroarray true debug false
structure 
    boolean value true

_____parsePut channel  DBRdouble provider pva request value zeroarray true debug false
_____parsePut channel  DBRdouble provider ca request value zeroarray true debug false
_____parsePut channel  DBRstring00 provider pva request value zeroarray true debug false
_____parsePut channel  DBRstring00 provider ca request value zeroarray true debug false
</pre>
<h3>exampleCPP/json/client/scripts/exampleScalarArray</h3>
<p>
This contains:
</p>
<pre>
source ./setEnv
${PARSE}/parsePut -r "" PVRdoubleArray value='[1,2,3]'
sleep .5
${PARSE}/parsePut -r "" DBRdoubleArray value='[1,2,3]'
sleep .5
${PARSE}/parsePut -r "" PVRdoubleArray '{"value":[10,20,30]}'
sleep .5
${PARSE}/parsePutGet -r "putField(value)getField(value)" PVRdoubleArray value='[100,200,300]'
sleep .5
${PARSE}/parsePut -r "" PVRstringArray value='["one","two","three"]'
sleep .5
${PARSE}/parsePut -r "" DBRstringArray01 value='["one","two","three"]'
sleep .5
${PARSE}/parsePut -r "" PVRstringArray '{"value":["one again","two again","three again"]}'
sleep .5
${PARSE}/parsePutGet -r "putField(value)getField(value)" PVRstringArray value='["once more","two again","three again"]'
sleep .5
${PARSE}/parsePut  -r "" PVRbooleanArray value='[true,false,true]'
sleep .5
${PARSE}/parsePut  -r "" PVRbooleanArray '{"value":[false,true,false]}'
sleep .5
${PARSE}/parsePutGet -r "putField(value)getField(value)" PVRbooleanArray value='[true,false,true]'
</pre>
<h3>exampleCPP/json/client/scripts/exampleEnum</h3>
<p>
This contains:
</p>
<pre>
#!/bin/sh
source ./setEnv
${PARSE}/parsePut -z false PVRenum value=one
sleep .5
${PARSE}/parsePut -z false DBRenum01 value=one
sleep .5
${PARSE}/parsePutGet -z false -r "putField(value)getField(value)" PVRenum value=zero
sleep .5
${PARSE}/parsePut -z false -p ca DBRenum01 value=zero
sleep .5
${PARSE}/parsePut PVRenum '{"value":{"index":1}}'
</pre>
<h3>exampleCPP/json/client/scripts/exampleUnion</h3>
<p>
This contains:
</p>
<pre>
#!/bin/sh
source ./setEnv
${PARSE}/parsePut PVRrestrictedUnion value='string="test string"'
sleep .5
${PARSE}/parsePut PVRrestrictedUnion value='stringArray=["test string","two"]'
sleep .5
${PARSE}/parsePut PVRrestrictedUnion value='point={"x":".1","y":".2"}'
sleep .5
${PARSE}/parsePut PVRrestrictedUnion value='union_t=string="test"'
sleep .5
${PARSE}/parsePut PVRrestrictedUnion value='union_t=point={"x":".1","y":".2"}'
</pre>
<h3>exampleCPP/json/client/scripts/exampleBigRecord</h3>
<p>
This contains:
</p>
<pre>
#!/bin/sh
source ./setEnv
${PARSE}/parsePut 
sleep .5
${PARSE}/parsePut -r "" PVRBigRecord scalar.double.value=10 scalarArray.double.value='[100,200]'
sleep .5
${PARSE}/parsePut -r "" PVRBigRecord '{"scalar":{"double":{"value":20}}}' '{"scalarArray":{"double":{"value":[1000,2000]}}}'
sleep .5
${PARSE}/parsePut -r "" PVRBigRecord scalar.double.value=10 scalar.string.value='" this is a string"'
sleep .5
${PARSE}/parsePut -r "" PVRBigRecord '{"scalar":{"double":{"value":20},"string":{"value":"this is also a string"}}}'
sleep .5
${PARSE}/parsePutGet -r "putField(),getField(scalar.double,scalarArray.double)" PVRBigRecord scalar.double.value=10 scalarArray.double.value='[100,200]'
</pre>

</div>
</body>
</html>
