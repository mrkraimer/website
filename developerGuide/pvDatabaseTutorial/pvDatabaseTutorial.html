<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>pvDatabase Tutorial</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>pvDatabase Tutorial</h1>

<h2 class="nocount">editions</h2>
<dl>
  <dt>2019.07.03</dt>
     <dd>Original</dd>
  <dt>2012.04.07</dt>
     <dd>Update</dd>
</dl>  
<dl>
  <dt>Editors:</dt>
    <dd>Marty Kraimer</dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Overview</h2>
<p>This tutorial has two main objectives:</p>
<dl>
   <dt>pvDatabase features</dt>
     <dd>Shows various features provided by pvDatabase itself.</dd>
   <dt>Implementing a PVRecord</dt>
     <dd>Explains how <b>exampleLink</b> is organized.
      It can be used as a model for implementing services based on PVRecords.
     </dd>
</dl>
<p>The following components of pvDatabaseCPP are also of interest.
</p>
<ol>
   <li>
     <a href="../pluginSupport/pluginSupport.html">pluginSupport</a>
   </li>
   <li>
     <a href="../recordSupport/recordSupport.html">recordSupport</a>
   </li>
   <li>
     <a href="../specialRecord/specialRecord.html">specialRecord</a>
   </li>
</ol>
<p>This tutorial assumes that you are somewhat familar with the following:</p>
<h4>developerGuide</h4>
<a href="../developerGuide.html">developerGuide</a>
Is an introducion to the various components of EPICS V4
<h4>exampleCPP</h4>
<a href="https://github.com/epics-base/exampleCPP">exampleCPP</a>
Is a set of EPICS V4 examples.
This tutorial is based on following examples:
<dl>
  <dt>database</dt>
     <dd>
     This provides a large set of PVRecords.
     </dd>
  <dt>exampleLink</dt>
     <dd>
     This example creates PVRecords that link to other records.
     Each can either use <b>pvaClient</b> to access the other record or can directly
     access it via the local <b>PVDatabase</b>.
     </dd>
  <dt>support</dt>
     <dd>
     This is an example that uses the <b>controlSupport</b> and <b>scalarAlarmSupport</b>
     from  <b>PVDatabase</b>.
     </dd>
</dl>

<h4>building</h4>
<p>
While reading this tutorial you are encouraged to try
the examples, which requires that you have built pvDatabaseCPP and exampleCPP.
</p>
pvDatabase is located at:
<a href="https://github.com/epics-base/pvDatabaseCPP">pvDatabaseCPP</a>
<br/>
exampleCPP is located at:
<a href="https://github.com/epics-base/exampleCPP">exampleCPP</a>

<h2>Starting the example IOCs</h2>
<p>
After building exampleCPP, start the databases for the support examples as follows:
</p>
<h4>database</h4>
In one window:
<pre>
pwd
/home/epics7/modules/exampleCPP/database/iocBoot/exampleDatabase
../../bin/linux-x86_64/exampleDatabase st.cmd
</pre>
<h4>exampleLink</h4>
In another window
<pre>
pwd
/home/epics7/modules/exampleCPP/exampleLink/iocBoot/exampleLink
../../bin/linux-x86_64/exampleLink st.cmd 
</pre>
<h4>support</h4>
<pre>
pwd
/home/epicsv4/masterCPP/exampleCPP/support/iocBoot/support
../../bin/linux-x86_64/support st.cmd 
</pre>
<h2>PVRecords implemented by pvDatabase</h2>
<p>These are all iocshell commands implemented by pvDatabase.
In:
</p>
<pre>
pwd
/home/epics7/modules/exampleCPP/database/iocBoot/exampleDatabase
</pre>
<p><b>st.cmd</b> has examples of the iocshell commands:</p>
<pre>
pvdbcrScalar PVRboolean boolean
pvdbcrScalar PVRbyte byte
pvdbcrScalar PVRshort short
pvdbcrScalar PVRint int
pvdbcrScalar PVRlong long
pvdbcrScalar PVRubyte ubyte
pvdbcrScalar PVRushort ushort 
pvdbcrScalar PVRuint uint
pvdbcrScalar PVRulong ulong
pvdbcrScalar PVRfloat float
pvdbcrScalar PVRdouble double
pvdbcrScalar PVRstring string
pvdbcrScalar PVRdouble01 double
pvdbcrScalar PVRdouble02 double
pvdbcrScalar PVRdouble03 double
pvdbcrScalar PVRdouble04 double
pvdbcrScalar PVRdouble05 double
pvdbcrScalarArray PVRbooleanArray boolean
pvdbcrScalarArray PVRbyteArray byte
pvdbcrScalarArray PVRshortArray short
pvdbcrScalarArray PVRintArray int
pvdbcrScalarArray PVRlongArray long
pvdbcrScalarArray PVRubyteArray ubyte
pvdbcrScalarArray PVRushortArray ushort 
pvdbcrScalarArray PVRuintArray uint
pvdbcrScalarArray PVRulongArray ulong
pvdbcrScalarArray PVRfloatArray float
pvdbcrScalarArray PVRdoubleArray double
pvdbcrScalarArray PVRstringArray string
pvdbcrScalarArray PVRdouble01Array double
pvdbcrScalarArray PVRdouble02Array double
pvdbcrScalarArray PVRdouble03Array double
pvdbcrScalarArray PVRdouble04Array double
pvdbcrScalarArray PVRdouble05Array double
pvdbcrTraceRecord PVRtraceRecord
pvdbcrRemoveRecord PVRremoveRecord
pvdbcrAddRecord PVRaddRecord
pvdbcrProcessRecord PVRprocessRecord .5
</pre>

<h3>pvdbcrScalar</h3>

<p>A created record  has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRscalarDouble
PVRscalarDouble
Server: 10.0.0.9:5075
Type:
    structure
        double value
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
</pre>
<p>
<b>NOTE:</b> The type can be any numeric scalar type,
i.e. byte,short,int,long,ubyte,ushort,uint,ulong, float, or double.
</p>


<h3>pvdbcrScalarArray</h3>

<p>A created record  has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRscalarArrayDouble
PVRscalarArrayDouble
Server: 10.0.0.9:5075
Type:
    structure
        double[] value 
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
</pre>
<p>
<b>NOTE:</b> The type can be any scalar type,
i.e. boolean,byte,short,int,long,ubyte,ushort,uint,ulong,float,double,string.
</p>

<h3>pvdbcrTraceRecord</h3>

<p>The created record sets the trace level in another pvRecord in the local pvDatabase.
The trace level determines what messages are displayed
when clients access the pvRecord.
If the level is 0 no messages are displayed.
If the level is 1 then connection and creation messages are displayed.
If the level is 2 then messages are displayed for all client interaction.
</p>
<p>A created record has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRtraceRecord
PVRtraceRecord
Server: 10.0.0.9:5075
Type:
    structure
        structure argument
            string recordName
            int level
        structure result
            string status
</pre>
<p>
An example of using the record is:
</p>
<pre>
mrk&amp; pvput -r "argument,result" PVRtraceRecord argument='{"recordName":"PVRscalarDouble","level":"2"}'
Old : structure 
    structure argument
        string recordName 
        int level 0
    structure result
        string status 
New : structure 
    structure argument
        string recordName PVRscalarDouble
        int level 2
    structure result
        string status success
</pre>
This sets the trace level to 2 in record PVRscalarDouble.
<p>
This record is not used in rest of this tutorial.
</p>

<h3>pvdbcrRemoveRecord</h3>

<p>The created record removes another pvRecord in the local pvDatabase.
</p>
<p>A created record that has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRremoveRecord
PVRremoveRecord
Server: 10.0.0.9:5075
Type:
    structure
        structure argument
            string recordName
        structure result
            string status
</pre>
<p>
An example of using the record is:
</p>
<pre>
mrk&amp; pvput -r "argument,result" PVRremoveRecord argument='{"recordName":"PVRscalarDouble"}'
Old : structure 
    structure argument
        string recordName 
    structure result
        string status 
New : structure 
    structure argument
        string recordName PVRscalarDouble
    structure result
        string status success

</pre>
This removes record PVRscalarDouble from the local pvDatabase.
<p>
This record is not used in rest of this tutorial.
</p>

<h3>pvdbcrProcessRecord</h3>

<p>The created record creates a thread that processes other records in the local pvDatabase.
Before each round of processing it delays for the numbeSupport for this record is implemented by pvDatabase.
The record supports two commands: <b>add</b> and <b>remove</b>.
</p>
<p>A created record has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRprocessRecord
PVRprocessRecord
Server: 10.0.0.9:5075
Type:
    structure
        structure argument
            string command
            string recordName
        structure result
            string status
</pre>
<p>
An example of using the record is:
</p>
<pre>
mrk&amp; pvput -r "argument,result" PVRprocessRecord argument='{"command":"add","recordName":"PVRscalarDouble"}'
Old : structure 
    structure argument
        string command 
        string recordName 
    structure result
        string status 
New : structure 
    structure argument
        string command add
        string recordName PVRscalarDouble
    structure result
        string status PVRscalarDouble not in pvDatabase
</pre>
This adds PVRscalarDouble to the set of records to process.
Note that the request failed because the previous pvput removed PVRscalarDouble.
<p>
This record is used in the rest of this tutorial.
</p>

<h2>exampleLink</h2>
<p>To start the database for this example:</p>
<pre>
pwd
/home/epics7/modules/exampleCPP/exampleLink/iocBoot/exampleLink
../../bin/linux-x86_64/exampleLink st.cmd
</pre>
<p>
When the IOC is started it has the following records:
</p>
<pre>
double              // value is a double
doubleArray         // value is a double array
string              // value is a string
stringArray         // value is a string array
getLinkScalar
getLinkScalarArray
putLinkScalar
putLinkScalarArray
</pre>
<p>
This example creates the following PVRecords:
</p>
<dl>
  <dt>getLinkScalar</dt>
    <dd>
      Gets data from another record, which must have a top level value field that is a  scalar.
    </dd>
  <dt>putLinkScalar</dt>
    <dd>
      Puts data to another record, which must have a top level value field that is a scalar.
    </dd>
  <dt>getLinkScalarArray</dt>
    <dd>
      Gets data from another record, which must have a top level value field that is a scalar array.
    </dd>
  <dt>putLinkScalarArray</dt>
    <dd>
      Puts data to another record, which must have a top level value field that is a  scalar array.
    </dd>
</dl>
<p>Each provides two methods for linking to the other record:
</p>
<dl>
   <dt>client</dt>
     <dd>
     Uses pvaClient to connect to the other record.
     This method can link to another record in the same IOC or in another IOC.
     </dd>
   <dt>database</dt>
     <dd>
     Uses PVDatabase to connect to the other record.
     This method can only link to another record in the same IOC.
     </dd>
</dl>
Except for the value field each of the get and put link records have the same structure.
For example <b>putLinkScalar</b> has the following structure:
<pre>
pvinfo putLinkScalar
putLinkScalar
Server: 10.0.0.10:5075
Type:
    structure
        string value
        string linkRecord
        string accessMethod
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
        alarm_t alarm
            int severity
            int status
            string message
        boolean reconnect
</pre>
where :
<dl>
   <dt>value</dt>
   <dd>
      The value to put to the linked record.
      <br/>
      For the Array version this is <b>string[] value</b>.
      <br/>
      The convert facility is used to convert between value and that value field of the linked record.
      <br/>
      For get the value is read from <b>linkRecord</b>.
      For put the value is written to <b>linkRecord</b>.
   </dd>
   <dt>linkRecord</dt>
   <dd>
   This is the name of the linked record.
   </dd>
   <dt>accessMethod</dt>
   <dd>
   This must be <b>client</b> or <b>database</b>
   </dd>
   <dt>timeStamp</dt>
   <dd>
   Shows time when record is processed.
   </dd>
   <dt>alarm</dt>
   <dd>
   Used to report success or errors when record is processed,
   </dd>
   <dt>reconnect</dt>
   <dd>
   When a connection is first made the connection is saved and used for future processing.
   The details differ depending on the accessMethod.
   If a client changes reconnect then a reconnect will be made the next time the record is processed.
   <br/>
   <b>NOTE:</b> Whenever the client wants to change the linkRecord or accessMethod, the clent must first reconnect.
   </dd>
</dl>
<p>In order to understand what the following examples do
start monitoring:
</p>
<pre>
pvget -m double doubleArray string stringArray getLinkScalar getLinkScalarArray putLinkScalar putLinkScalarArray PVRdouble
</pre>
<p>
Then in another window:
</p>
<pre>
pvput putLinkScalar '{"value":"1","linkRecord":"double","accessMethod":"client"}'
</pre>
<br/>
and then:
<pre>
pvput putLinkScalar reconnect=true
</pre>
and then:
<pre>
pvput putLinkScalar '{"value":"1","linkRecord":"PVRdouble","accessMethod":"client"}'
</pre>
<p>Where you are monitoring you will see:
</p>
<pre>
double             2021-04-06 08:38:28.917  1 
putLinkScalar      2021-04-06 08:38:28.917  1 
double             2021-04-06 08:39:43.251  1 
putLinkScalar      2021-04-06 08:39:43.251  1 
putLinkScalar      2021-04-06 08:40:39.009  1 MINOR reconnecting 
PVRdouble          2021-04-06 08:43:16.973  1 
putLinkScalar      2021-04-06 08:43:16.973  1 
</pre>
<p>Now lets try an array example using database and also getLink.
</p>
<pre>
pvput putLinkScalarArray '{"value":["1","2","3"],"linkRecord":"doubleArray","accessMethod":"database"}'
</pre>
and then:
<pre>
pvput getLinkScalarArray '{"linkRecord":"doubleArray","accessMethod":"database"}'
</pre>
<p>Where you are monitoring you will see:
</p>
<pre>
doubleArray        2021-04-06 08:51:58.312  [1,2,3]
putLinkScalarArray 2021-04-06 08:51:58.312  [1, 2, 3]
getLinkScalarArray 2021-04-06 08:54:29.538  [1, 2, 3]
</pre>
<h2>Building exampleLink</h2>
<p>This section describes the files that appear in <b>exampleCPP/exampleLink</b>.
This example is a good way to help understand how to build a service based
on PVRecords. The PVRecords can be in a standalone pvDatabase or can be in
an IOC that also contains DBRecords.
</p>
<p>After executing make, exampleCPP/exampleLink has the following subdirectories:
</p>
<pre>
mrk&amp; ls | cat
bin           // generated by make
configure     // standard files for building an appplication
db            // generated by make for what is in ioc/Db
dbd           // generated by make for what is in ioc/src
ioc           // see below
iocBoot       // see below
lib           // generated by make
Makefile
README.md
src           // see below
client        // was described in previous section
</pre>
<h3>exampleLink/src</h3>
<p>
This has the files:
</p>
<pre>
getLinkScalarArrayRegister.cpp
getLinkScalarArrayRegister.dbd
getLinkScalarRegister.cpp
getLinkScalarRegister.dbd
putLinkScalarArrayRegister.cpp
putLinkScalarArrayRegister.dbd
putLinkScalarRegister.cpp
putLinkScalarRegister.dbd
Makefile
</pre>
<p>
<b>getLinkScalarRegister.dbd</b> is:</p>
<pre>
registrar("getLinkScalarRegister")
</pre>
<h4>getLinkScalarArrayRegister.cpp</h4>
<p>This starts with:</p>
<pre>
#include &lt;iocsh.h&gt;
#include &lt;pv/standardField.h&gt;
#include &lt;pv/standardPVField.h&gt;
#include &lt;pv/timeStamp.h&gt;
#include &lt;pv/pvTimeStamp.h&gt;
#include &lt;pv/alarm.h&gt;
#include &lt;pv/pvAlarm.h&gt;
#include &lt;pv/pvDatabase.h&gt;
#include &lt;pv/pvaClient.h&gt;
#include &lt;pv/convert.h&gt;
// The following must be the last include for code exampleLink uses
#include &lt;epicsExport.h&gt;
#define epicsExportSharedSymbols

using namespace epics::pvData;
using namespace epics::pvAccess;
using namespace epics::pvDatabase;
using namespace epics::pvaClient;
using namespace std;
</pre>
<p>This includes everything required in order to implement a PVRecord.</p>
<p>Next is the class definition.</p>
<pre>
class GetLinkScalarRecord;
typedef std::tr1::shared_ptr&lt;GetLinkScalarRecord&gt;GetLinkScalarRecordPtr;

class epicsShareClass GetLinkScalarRecord :
    public epics::pvDatabase::PVRecord
{
private:
    GetLinkScalarRecord(
        std::string const &amp; recordName,
        PVStructurePtr const &amp; pvStructure);    
    PVStringPtr pvValue;      
    PVStringPtr pvLink;
    PVStringPtr pvAccessMethod;
    PVStructurePtr pvAlarmField;
    PVAlarm pvAlarm;
    Alarm alarm;
    epics::pvDatabase::PVRecordWPtr linkRecord;
    epics::pvaClient::PvaClientChannelPtr linkChannel;
    epics::pvaClient::PvaClientGetPtr clientGet;
    PVBooleanPtr pvReconnect;
    void clientProcess();
    void databaseProcess();
public:
    POINTER_DEFINITIONS(GetLinkScalarRecord);
    static GetLinkScalarRecordPtr create(std::string const &amp; recordName);
    virtual ~GetLinkScalarRecord() {}
    virtual void process();
    virtual bool init();
};
</pre>
<p>That is followed by the implemention code.
Look at the actual code for details.
But note that the <b>process</b> method is:
</p>
<pre>
void GetLinkScalarRecord::process()
{
   bool reconnect = (pvReconnect->get() ? true : false);
   if(reconnect) {
       linkRecord = PVRecordWPtr();
       clientGet = PvaClientGetPtr();
       linkChannel = PvaClientChannelPtr();
       pvReconnect-&gt;put(false);
       alarm.setMessage("reconnecting");
       alarm.setSeverity(minorAlarm);
       pvAlarm.set(alarm);
       PVRecord::process();
       return;
   }
   std::string accessMethod = pvAccessMethod->get();
   if(accessMethod.compare("client")==0) {
        clientProcess();
        return;
   }
   if(accessMethod.compare("database")==0) {
        databaseProcess();
        return;
   }
   alarm.setMessage("illegal accessMethod: must be client or database");
   alarm.setSeverity(invalidAlarm);
   pvAlarm.set(alarm);
   PVRecord::process();   
}
...
void GetLinkScalarRecord::clientProcess()  //  This uses pvaClient
{
...
void GetLinkScalarRecord::databaseProcess() // This uses PVDatabase
{
...
</pre>
<p>
After the code that implements the PVRecord is the code for creating the iocshell command:
</p>
<pre>
static const iocshArg arg0 = { "recordName", iocshArgString };
static const iocshArg *args[] = {&amp;arg0};

static const iocshFuncDef getLinkScalarFuncDef = {
    "getLinkScalar", 1, args};
static void getLinkScalarCallFunc(const iocshArgBuf *args)
{
    string getLinkScalarRecord("getLinkScalar");
    char *sval = args[0].sval;
    if(sval) getLinkScalarRecord = string(sval);
    PVDatabasePtr master = PVDatabase::getMaster();
    bool result(false);
    GetLinkScalarRecordPtr record = GetLinkScalarRecord::create(getLinkScalarRecord);
    if(record) 
        result = master-&gt;addRecord(record);
    if(!result) cout &lt;&lt; "recordname" &lt;&lt; " not added" &lt;&lt; endl;
}

static void getLinkScalarRegister(void)
{
    static int firstTime = 1;
    if (firstTime) {
        firstTime = 0;
        iocshRegister(&amp;getLinkScalarFuncDef, getLinkScalarCallFunc);
    }
}

extern "C" {
    epicsExportRegistrar(getLinkScalarRegister);
}
</pre>


<h3>exampleLink/ioc</h3>
<p>This directory creates the IOC code for this example.</p>
<h4>Db</h4>
<p>
This is where DBRecords are configured.
</p>
<h4>src</h4>
<p>The is where the code for the IOC is built.
In particular look at exampleLinkInclude.dbd:
</p>
<pre>
include "base.dbd"                          // standard for V3
include "PVAClientRegister.dbd"             // standard for V4              
include "PVAServerRegister.dbd"             // standard for V4 
include "registerChannelProviderLocal.dbd"  // standard for pvDatabase 
include "qsrv.dbd"                          // standard for V4 
include "putLinkScalarRegister.dbd"         // implemented by exampleLink
include "putLinkScalarArrayRegister.dbd"    // implemented by exampleLink
include "getLinkScalarRegister.dbd"         // implemented by exampleLink
include "getLinkScalarArrayRegister.dbd"    // implemented by exampleLink
include "pvdbSpecialRegister.dbd"           // implemented by pvDatabase
</pre>
<h3>exampleLink/iocBoot</h3>
<h4>iocBoot/exampleLink</h4>
<p>st.cmd is:</p>
<pre>
&lt; envPaths

cd ${TOP}

## Register all support components
dbLoadDatabase("dbd/exampleLink.dbd")
exampleLink_registerRecordDeviceDriver(pdbbase)

## Load record instance
dbLoadRecords("db/ai.db","name=exampleLinkAI");
cd ${TOP}/iocBoot/${IOC}
##asSetFilename(asconfig)
iocInit()
pvdbcrScalar double double
pvdbcrScalar string string
pvdbcrScalarArray doubleArray double
pvdbcrScalarArray stringArray string

putLinkScalar putLinkScalar
putLinkScalarArray putLinkScalarArray

getLinkScalar getLinkScalar
getLinkScalarArray getLinkScalarArray
</pre>

</div>
</body>
</html>
