<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>pvDatabase Tutorial</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>pvDatabase Tutorial</h1>

<h2 class="nocount">editions</h2>
<dl>
  <dt>2019.07.03</dt>
     <dd>Original</dd>
  <dt>2012.04.06</dt>
     <dd>Update</dd>
</dl>  
<dl>
  <dt>Editors:</dt>
    <dd>Marty Kraimer</dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">

<h2>Overview</h2>
<p>This tutorial has two main objectives:</p>
<dl>
   <dt>pvDatabase features</dt>
     <dd>Shows various features provided by pvDatabase itself.</dd>
   <dt>Implementing a PVRecord</dt>
     <dd>Explains how <b>exampleLink</b> is organized.
      It can be used as a model for implementing services based on PVRecords.
      <br/>
      It also describes <b>support</b>, which shows how to use another feature provided by <b>pvDatabase</b>.
     </dd>
</dl>
<p>The following components of pvDatabaseCPP are also of interest.
</p>
<ol>
   <li>
     <a href="../pluginSupport/pluginSupport.html">pluginSupport</a>
   </li>
   <li>
     <a href="../recordSupport/recordSupport.html">recordSupport</a>
   </li>
   <li>
     <a href="../specialRecord/specialRecord.html">specialRecord</a>
   </li>
</ol>
<p>This tutorial assumes that you are somewhat familar with the following:</p>
<h4>developerGuide</h4>
<a href="../developerGuide.html">developerGuide</a>
Is an introducion to the various components of EPICS V4
<h4>exampleCPP</h4>
<a href="https://github.com/epics-base/exampleCPP">exampleCPP</a>
Is a set of EPICS V4 examples.
This tutorial is based on following examples:
<dl>
  <dt>database</dt>
     <dd>
     This provides a large set of PVRecords.
     </dd>
  <dt>exampleLink</dt>
     <dd>
     This example creates PVRecords that link to other records.
     Each can either use <b>pvaClient</b> to access the other record or can directly
     access it via the local <b>PVDatabase</b>.
     </dd>
  <dt>support</dt>
     <dd>
     This is an example that uses the <b>controlSupport</b> and <b>scalarAlarmSupport</b>
     from  <b>PVDatabase</b>.
     </dd>
</dl>

<h4>building</h4>
<p>
While reading this tutorial you are encouraged to try
the examples, which requires that you have built pvDatabaseCPP and exampleCPP.
</p>
pvDatabase is located at:
<a href="https://github.com/epics-base/pvDatabaseCPP">pvDatabaseCPP</a>
<br/>
exampleCPP is located at:
<a href="https://github.com/epics-base/exampleCPP">exampleCPP</a>

<h2>Starting the example IOCs</h2>
<p>
After building exampleCPP, start the databases for the support examples as follows:
</p>
<h4>database</h4>
In one window:
<pre>
pwd
/home/epics7/modules/exampleCPP/database/iocBoot/exampleDatabase
../../bin/linux-x86_64/exampleDatabase st.cmd
</pre>
<h4>exampleLink</h4>
In another window
<pre>
pwd
/home/epics7/modules/exampleCPP/exampleLink/iocBoot/exampleLink
../../bin/linux-x86_64/exampleLink st.cmd 
</pre>
<h4>support</h4>
<pre>
pwd
/home/epicsv4/masterCPP/exampleCPP/support/iocBoot/support
../../bin/linux-x86_64/support st.cmd 
</pre>
<h2>PVRecords implemented by pvDatabase</h2>
<p>These are all iocshell commands implemented by pvDatabase.
In:
</p>
<pre>
pwd
/home/epics7/modules/exampleCPP/database/iocBoot/exampleDatabase
</pre>
<p><b>st.cmd</b> has examples of the iocshell commands:</p>
<pre>
pvdbcrScalar PVRboolean boolean
pvdbcrScalar PVRbyte byte
pvdbcrScalar PVRshort short
pvdbcrScalar PVRint int
pvdbcrScalar PVRlong long
pvdbcrScalar PVRubyte ubyte
pvdbcrScalar PVRushort ushort 
pvdbcrScalar PVRuint uint
pvdbcrScalar PVRulong ulong
pvdbcrScalar PVRfloat float
pvdbcrScalar PVRdouble double
pvdbcrScalar PVRstring string
pvdbcrScalar PVRdouble01 double
pvdbcrScalar PVRdouble02 double
pvdbcrScalar PVRdouble03 double
pvdbcrScalar PVRdouble04 double
pvdbcrScalar PVRdouble05 double
pvdbcrScalarArray PVRbooleanArray boolean
pvdbcrScalarArray PVRbyteArray byte
pvdbcrScalarArray PVRshortArray short
pvdbcrScalarArray PVRintArray int
pvdbcrScalarArray PVRlongArray long
pvdbcrScalarArray PVRubyteArray ubyte
pvdbcrScalarArray PVRushortArray ushort 
pvdbcrScalarArray PVRuintArray uint
pvdbcrScalarArray PVRulongArray ulong
pvdbcrScalarArray PVRfloatArray float
pvdbcrScalarArray PVRdoubleArray double
pvdbcrScalarArray PVRstringArray string
pvdbcrScalarArray PVRdouble01Array double
pvdbcrScalarArray PVRdouble02Array double
pvdbcrScalarArray PVRdouble03Array double
pvdbcrScalarArray PVRdouble04Array double
pvdbcrScalarArray PVRdouble05Array double
pvdbcrTraceRecord PVRtraceRecord
pvdbcrRemoveRecord PVRremoveRecord
pvdbcrAddRecord PVRaddRecord
pvdbcrProcessRecord PVRprocessRecord .5
</pre>

<h3>pvdbcrScalar</h3>

<p>A created record  has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRscalarDouble
PVRscalarDouble
Server: 10.0.0.9:5075
Type:
    structure
        double value
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
</pre>
<p>
<b>NOTE:</b> The type can be any numeric scalar type,
i.e. byte,short,int,long,ubyte,ushort,uint,ulong, float, or double.
</p>


<h3>pvdbcrScalarArray</h3>

<p>A created record  has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRscalarArrayDouble
PVRscalarArrayDouble
Server: 10.0.0.9:5075
Type:
    structure
        double[] value 
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
</pre>
<p>
<b>NOTE:</b> The type can be any scalar type,
i.e. boolean,byte,short,int,long,ubyte,ushort,uint,ulong,float,double,string.
</p>

<h3>pvdbcrTraceRecord</h3>

<p>The created record sets the trace level in another pvRecord in the local pvDatabase.
The trace level determines what messages are displayed
when clients access the pvRecord.
If the level is 0 no messages are displayed.
If the level is 1 then connection and creation messages are displayed.
If the level is 2 then messages are displayed for all client interaction.
</p>
<p>A created record has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRtraceRecord
PVRtraceRecord
Server: 10.0.0.9:5075
Type:
    structure
        structure argument
            string recordName
            int level
        structure result
            string status
</pre>
<p>
An example of using the record is:
</p>
<pre>
mrk&amp; pvput -r "argument,result" PVRtraceRecord argument='{"recordName":"PVRscalarDouble","level":"2"}'
Old : structure 
    structure argument
        string recordName 
        int level 0
    structure result
        string status 
New : structure 
    structure argument
        string recordName PVRscalarDouble
        int level 2
    structure result
        string status success
</pre>
This sets the trace level to 2 in record PVRscalarDouble.
<p>
This record is not used in rest of this tutorial.
</p>

<h3>pvdbcrRemoveRecord</h3>

<p>The created record removes another pvRecord in the local pvDatabase.
</p>
<p>A created record that has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRremoveRecord
PVRremoveRecord
Server: 10.0.0.9:5075
Type:
    structure
        structure argument
            string recordName
        structure result
            string status
</pre>
<p>
An example of using the record is:
</p>
<pre>
mrk&amp; pvput -r "argument,result" PVRremoveRecord argument='{"recordName":"PVRscalarDouble"}'
Old : structure 
    structure argument
        string recordName 
    structure result
        string status 
New : structure 
    structure argument
        string recordName PVRscalarDouble
    structure result
        string status success

</pre>
This removes record PVRscalarDouble from the local pvDatabase.
<p>
This record is not used in rest of this tutorial.
</p>

<h3>pvdbcrProcessRecord</h3>

<p>The created record creates a thread that processes other records in the local pvDatabase.
Before each round of processing it delays for the numbeSupport for this record is implemented by pvDatabase.
The record supports two commands: <b>add</b> and <b>remove</b>.
</p>
<p>A created record has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRprocessRecord
PVRprocessRecord
Server: 10.0.0.9:5075
Type:
    structure
        structure argument
            string command
            string recordName
        structure result
            string status
</pre>
<p>
An example of using the record is:
</p>
<pre>
mrk&amp; pvput -r "argument,result" PVRprocessRecord argument='{"command":"add","recordName":"PVRscalarDouble"}'
Old : structure 
    structure argument
        string command 
        string recordName 
    structure result
        string status 
New : structure 
    structure argument
        string command add
        string recordName PVRscalarDouble
    structure result
        string status PVRscalarDouble not in pvDatabase
</pre>
This adds PVRscalarDouble to the set of records to process.
Note that the request failed because the previous pvput removed PVRscalarDouble.
<p>
This record is used in the rest of this tutorial.
</p>

<h2>exampleLink</h2>
<p>To start the database for this example:</p>
<pre>
pwd
/home/epics7/modules/exampleCPP/exampleLink/iocBoot/exampleLink
../../bin/linux-x86_64/exampleLink st.cmd
</pre>
<p>
When the IOC is started it has the following records:
</p>
<pre>
double              // value is a double
doubleArray         // value is a double array
string              // value is a string
stringArray         // value is a string array
getLinkScalar
getLinkScalarArray
putLinkScalar
putLinkScalarArray
</pre>
<p>
This example creates the following PVRecords:
</p>
<dl>
  <dt>getLinkScalar</dt>
    <dd>
      Gets data from another record, which must have a top level value field that is a  scalar.
    </dd>
  <dt>putLinkScalar</dt>
    <dd>
      Puts data to another record, which must have a top level value field that is a scalar.
    </dd>
  <dt>getLinkScalarArray</dt>
    <dd>
      Gets data from another record, which must have a top level value field that is a scalar array.
    </dd>
  <dt>putLinkScalarArray</dt>
    <dd>
      Puts data to another record, which must have a top level value field that is a  scalar array.
    </dd>
</dl>
<p>Each provides two methods for linking to the other record:
</p>
<dl>
   <dt>client</dt>
     <dd>
     Uses pvaClient to connect to the other record.
     This method can link to another record in the same IOC or in another IOC.
     </dd>
   <dt>database</dt>
     <dd>
     Uses PVDatabase to connect to the other record.
     This method can only link to another record in the same IOC.
     </dd>
</dl>
Except for the value field each of the get and put link records have the same structure.
For example <b>putLinkScalar</b> has the following structure:
<pre>
pvinfo putLinkScalar
putLinkScalar
Server: 10.0.0.10:5075
Type:
    structure
        string value
        string linkRecord
        string accessMethod
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
        alarm_t alarm
            int severity
            int status
            string message
        boolean reconnect
</pre>
where :
<dl>
   <dt>value</dt>
   <dd>
      The value to put to the linked record.
      <br/>
      For the Array version this is <b>string[] value</b>.
      <br/>
      The convert facility is used to convert between value and that value field of the linked record.
      <br/>
      For get the value is read from <b>linkRecord</b>.
      For put the value is written to <b>linkRecord</b>.
   </dd>
   <dt>linkRecord</dt>
   <dd>
   This is the name of the linked record.
   </dd>
   <dt>accessMethod</dt>
   <dd>
   This must be <b>client</b> or <b>database</b>
   </dd>
   <dt>timeStamp</dt>
   <dd>
   Shows time when record is processed.
   </dd>
   <dt>alarm</dt>
   <dd>
   Used to report success or errors when record is processed,
   </dd>
   <dt>reconnect</dt>
   <dd>
   When a connection is first made the connection is saved and used for future processing.
   The details differ depending on the accessMethod.
   If a client changes reconnect then a reconnect will be made the next time the record is processed.
   <br/>
   <b>NOTE:</b> Whenever the client wants to change the linkRecord or accessMethod, the clent must first reconnect.
   </dd>
</dl>
<p>In order to understand what the following examples do
start monitoring:
</p>
<pre>
pvget -m double doubleArray string stringArray getLinkScalar getLinkScalarArray putLinkScalar putLinkScalarArray PVRdouble
</pre>
<p>
Then in another window:
</p>
<pre>
pvput putLinkScalar '{"value":"1","linkRecord":"double","accessMethod":"client"}'
</pre>
<br/>
and then:
<pre>
pvput putLinkScalar reconnect=true
</pre>
and then:
<pre>
pvput putLinkScalar '{"value":"1","linkRecord":"PVRdouble","accessMethod":"client"}'
</pre>
<p>Where you are monitoring you will see:
</p>
<pre>
double             2021-04-06 08:38:28.917  1 
putLinkScalar      2021-04-06 08:38:28.917  1 
double             2021-04-06 08:39:43.251  1 
putLinkScalar      2021-04-06 08:39:43.251  1 
putLinkScalar      2021-04-06 08:40:39.009  1 MINOR reconnecting 
PVRdouble          2021-04-06 08:43:16.973  1 
putLinkScalar      2021-04-06 08:43:16.973  1 
</pre>
<p>Now lets try an array example using database and also getLink.
</p>
<pre>
pvput putLinkScalarArray '{"value":["1","2","3"],"linkRecord":"doubleArray","accessMethod":"database"}'
</pre>
and then:
<pre>
pvput getLinkScalarArray '{"linkRecord":"doubleArray","accessMethod":"database"}'
</pre>
<p>Where you are monitoring you will see:
</p>
<pre>
doubleArray        2021-04-06 08:51:58.312  [1,2,3]
putLinkScalarArray 2021-04-06 08:51:58.312  [1, 2, 3]
getLinkScalarArray 2021-04-06 08:54:29.538  [1, 2, 3]
</pre>
<h2>Building exampleLink</h2>
<p>This section describes the files that appear in <b>exampleCPP/exampleLink</b>.
This example is a good way to help understand how to build a service based
on PVRecords. The PVRecords can be in a standalone pvDatabase or can be in
an IOC that also contains DBRecords.
</p>
<p>After executing make, exampleCPP/exampleLink has the following subdirectories:
</p>
<pre>
mrk&amp; ls | cat
bin           // generated by make
configure     // standard files for building an appplication
db            // generated by make for what is in ioc/Db
dbd           // generated by make for what is in ioc/src
ioc           // see below
iocBoot       // see below
lib           // generated by make
Makefile
README.md
src           // see below
client        // was described in previous section
</pre>
<h3>exampleLink/src</h3>
<p>
This has the files:
</p>
<pre>
getLinkScalarArrayRegister.cpp
getLinkScalarArrayRegister.dbd
getLinkScalarRegister.cpp
getLinkScalarRegister.dbd
putLinkScalarArrayRegister.cpp
putLinkScalarArrayRegister.dbd
putLinkScalarRegister.cpp
putLinkScalarRegister.dbd
Makefile
</pre>
<p>
<b>getLinkScalarRegister.dbd</b> is:</p>
<pre>
registrar("getLinkScalarRegister")
</pre>
<h4>getLinkScalarArrayRegister.cpp</h4>
<p>This starts with:</p>
<pre>
#include &lt;iocsh.h&gt;
#include &lt;pv/standardField.h&gt;
#include &lt;pv/standardPVField.h&gt;
#include &lt;pv/timeStamp.h&gt;
#include &lt;pv/pvTimeStamp.h&gt;
#include &lt;pv/alarm.h&gt;
#include &lt;pv/pvAlarm.h&gt;
#include &lt;pv/pvDatabase.h&gt;
#include &lt;pv/pvaClient.h&gt;
#include &lt;pv/convert.h&gt;
// The following must be the last include for code exampleLink uses
#include &lt;epicsExport.h&gt;
#define epicsExportSharedSymbols

using namespace epics::pvData;
using namespace epics::pvAccess;
using namespace epics::pvDatabase;
using namespace epics::pvaClient;
using namespace std;
</pre>
<p>This includes everything required in order to implement a PVRecord.</p>
<p>Next is the class definition.</p>
<pre>
class GetLinkScalarRecord;
typedef std::tr1::shared_ptr&lt;GetLinkScalarRecord&gt;GetLinkScalarRecordPtr;

class epicsShareClass GetLinkScalarRecord :
    public epics::pvDatabase::PVRecord
{
private:
    GetLinkScalarRecord(
        std::string const &amp; recordName,
        PVStructurePtr const &amp; pvStructure);    
    PVStringPtr pvValue;      
    PVStringPtr pvLink;
    PVStringPtr pvAccessMethod;
    PVStructurePtr pvAlarmField;
    PVAlarm pvAlarm;
    Alarm alarm;
    epics::pvDatabase::PVRecordWPtr linkRecord;
    epics::pvaClient::PvaClientChannelPtr linkChannel;
    epics::pvaClient::PvaClientGetPtr clientGet;
    PVBooleanPtr pvReconnect;
    void clientProcess();
    void databaseProcess();
public:
    POINTER_DEFINITIONS(GetLinkScalarRecord);
    static GetLinkScalarRecordPtr create(std::string const &amp; recordName);
    virtual ~GetLinkScalarRecord() {}
    virtual void process();
    virtual bool init();
};
</pre>
<p>That is followed by the implemention code.
Look at the actual code for details.
But note that the <b>process</b> method is:
</p>
<pre>
void GetLinkScalarRecord::process()
{
   bool reconnect = (pvReconnect->get() ? true : false);
   if(reconnect) {
       linkRecord = PVRecordWPtr();
       clientGet = PvaClientGetPtr();
       linkChannel = PvaClientChannelPtr();
       pvReconnect-&gt;put(false);
       alarm.setMessage("reconnecting");
       alarm.setSeverity(minorAlarm);
       pvAlarm.set(alarm);
       PVRecord::process();
       return;
   }
   std::string accessMethod = pvAccessMethod->get();
   if(accessMethod.compare("client")==0) {
        clientProcess();
        return;
   }
   if(accessMethod.compare("database")==0) {
        databaseProcess();
        return;
   }
   alarm.setMessage("illegal accessMethod: must be client or database");
   alarm.setSeverity(invalidAlarm);
   pvAlarm.set(alarm);
   PVRecord::process();   
}
...
void GetLinkScalarRecord::clientProcess()  //  This uses pvaClient
{
...
void GetLinkScalarRecord::databaseProcess() // This uses PVDatabase
{
...
</pre>
<p>
After the code that implements the PVRecord is the code for creating the iocshell command:
</p>
<pre>
static const iocshArg arg0 = { "recordName", iocshArgString };
static const iocshArg *args[] = {&amp;arg0};

static const iocshFuncDef getLinkScalarFuncDef = {
    "getLinkScalar", 1, args};
static void getLinkScalarCallFunc(const iocshArgBuf *args)
{
    string getLinkScalarRecord("getLinkScalar");
    char *sval = args[0].sval;
    if(sval) getLinkScalarRecord = string(sval);
    PVDatabasePtr master = PVDatabase::getMaster();
    bool result(false);
    GetLinkScalarRecordPtr record = GetLinkScalarRecord::create(getLinkScalarRecord);
    if(record) 
        result = master-&gt;addRecord(record);
    if(!result) cout &lt;&lt; "recordname" &lt;&lt; " not added" &lt;&lt; endl;
}

static void getLinkScalarRegister(void)
{
    static int firstTime = 1;
    if (firstTime) {
        firstTime = 0;
        iocshRegister(&amp;getLinkScalarFuncDef, getLinkScalarCallFunc);
    }
}

extern "C" {
    epicsExportRegistrar(getLinkScalarRegister);
}
</pre>


<h3>exampleLink/ioc</h3>
<p>This directory creates the IOC code for this example.</p>
<h4>Db</h4>
<p>
This is where DBRecords are configured.
</p>
<h4>src</h4>
<p>The is where the code for the IOC is built.
In particular look at exampleLinkInclude.dbd:
</p>
<pre>
include "base.dbd"                          // standard for V3
include "PVAClientRegister.dbd"             // standard for V4              
include "PVAServerRegister.dbd"             // standard for V4 
include "registerChannelProviderLocal.dbd"  // standard for pvDatabase 
include "qsrv.dbd"                          // standard for V4 
include "putLinkScalarRegister.dbd"         // implemented by exampleLink
include "putLinkScalarArrayRegister.dbd"    // implemented by exampleLink
include "getLinkScalarRegister.dbd"         // implemented by exampleLink
include "getLinkScalarArrayRegister.dbd"    // implemented by exampleLink
include "pvdbSpecialRegister.dbd"           // implemented by pvDatabase
</pre>
<h3>exampleLink/iocBoot</h3>
<h4>iocBoot/exampleLink</h4>
<p>st.cmd is:</p>
<pre>
&lt; envPaths

cd ${TOP}

## Register all support components
dbLoadDatabase("dbd/exampleLink.dbd")
exampleLink_registerRecordDeviceDriver(pdbbase)

## Load record instance
dbLoadRecords("db/ai.db","name=exampleLinkAI");
cd ${TOP}/iocBoot/${IOC}
##asSetFilename(asconfig)
iocInit()
pvdbcrScalar double double
pvdbcrScalar string string
pvdbcrScalarArray doubleArray double
pvdbcrScalarArray stringArray string

putLinkScalar putLinkScalar
putLinkScalarArray putLinkScalarArray

getLinkScalar getLinkScalar
getLinkScalarArray getLinkScalarArray
</pre>

<h2>support</h2>
<p><b>NOTE:</b>
Support for control is defined by a combination of definitions in pvData and in pvDatabase.
I think the semantics are wrong.
I think two improvments should be made:
</p>
<dl>
   <dt>minStep</dt>
   <dd>
   This should be named <b>maxStep</b>.
   </dd>
   <dt>value</dt>
   <dd>
   This is what should be changed by maxStep each time the record is processed.
   </dd>
</dl>
<h3>Starting support</h3>
<p>To start the database for this example:</p>
<pre>
pwd
/home/epics7/modules/exampleCPP/support/iocBoot/support
../../bin/linux-x86_64/support st.cmd
</pre>
<p>
When the IOC is started it has the following records:
</p>
<pre>
PVRsupportDouble
PVRsupportProcessRecord
PVRsupportUByte
</pre>
<h4>supportRecordCreate</h4>
<p>This is an iocshell command implemented in exampleCPP/support.
It creates PVRecord instances that are used and described later in this tutorial.
The created record uses the <b>control</b> and <b>scalarAlarm</b> support from
pvDatabase.
</p>
<p>A created record has the following structure:</p>
<pre>
mrk&amp; pvinfo PVRsupportDouble
PVRsupportDouble
Server: 10.0.0.9:5075
Type:
    structure
        double value
        boolean reset
        alarm_t alarm
            int severity
            int status
            string message
        time_t timeStamp
            long secondsPastEpoch
            int nanoseconds
            int userTag
        display_t display
            double limitLow
            double limitHigh
            string description
            string format
            string units
        control_t control
            double limitLow
            double limitHigh
            double minStep
            double outputValue
        scalarAlarm_t scalarAlarm
            double lowAlarmLimit
            double lowWarningLimit
            double highWarningLimit
            double highAlarmLimit
            double hysteresis
</pre>
example usage appears later in this tutorial.
<h3>Use configAll script to configure records</h3>
<p>Run the following:</p>
<pre>
pwd
/home/epicsv4/masterCPP/exampleCPP/support/client/scripts
./configAll
</pre>
<p>configAll does the following:</p>
<ul>
   <li>
    Sets control and scalarAlarm fields for both PVRsupportDouble and PVRsupportUByte.
   </li>
   <li>
    Asks PVRprocessRecord to process PVRsupportDouble and PVRsupportUByte.
    <br />
    Thus each of these records will be periodically processed.
   </li>
</ul>
<h3>Run an example client</h3>
<h4>Look at the following</h4>
<pre>
pvget -r "control,scalarAlarm" PVRsupportDouble
PVRsupportDouble structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 10
    scalarAlarm_t scalarAlarm
        double lowAlarmLimit -8
        double lowWarningLimit -6
        double highWarningLimit 6
        double highAlarmLimit 8
        double hysteresis 0.1
</pre>
<h4>In one window enter</h4>
<pre>
pvget -m -r "value,control.outputValue,alarm,timeStamp" -v PVRsupportDouble
</pre>
The output from this window will be described after you enter the next command.
<h4>Enter:</h4>
<pre>
pvput PVRsupportDouble  20
</pre>
<h4>Results</h4>
In the window where you issued pvget you will first see:
<pre>
PVRsupportDouble structure 
    double value 10
    structure control
        double outputValue 0.5
    alarm_t alarm MAJOR RECORD major high alarm 
        int severity 2
        int status 3
        string message major high alarm
    time_t timeStamp 2019-07-01 09:32:51.793  
        long secondsPastEpoch 1561987971
        int nanoseconds 792512003
</pre>
<p>
<b>value</b> only went to 10 because that is the control limit.
<b>alarm</b> shows the values determined by scalarAlarm .
<b>outputValue</b> is .5 because of minStep.
</p>
<p>Next you will see output like:</p>
<pre>
PVRsupportDouble structure 
    structure control
        double outputValue .5
    time_t timeStamp 2021-04-06 10:39:28.987
        int nanoseconds 968025553
</pre>
<p>This will continue until You see:</p>
<pre>
PVRsupportDouble structure 
    structure control
        double outputValue 10
    time_t timeStamp  2021-04-06 10:44:50.660
        int nanoseconds 973958435
</pre>
<p>No more output occurs because <b>outputValue</b> is now equal to <b>value</b>.
</p>
<p>Later in the tutorial there is a similar example except for channel <b>PVRsupportUByte</b>.
</p>
<h3>scripts</h3>
<p>The scripts all appear in:
</p>
<pre>
mrk&amp; pwd
/home/epicsv4/masterCPP/exampleCPP/support/client/scripts
</pre>
<p>The scripts with names that start with config can be run either interactively
or via arguments.
The only exception is <b>configAll</b>
</p>

<h4>configControl</h4>
<p>
An example usage is:
</p>
<pre>
./configControl
recordName?
PVRsupportDouble
limitLow
-10
limitHigh
10
minStep
.5
Old : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2.5
New : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 2.5
</pre>
<p>It could do the same without prompts via:
</p>
<pre>
./configControl PVRsupportDouble -10 10 .5
Old : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 10
New : structure 
    control_t control
        double limitLow -10
        double limitHigh 10
        double minStep 0.5
        double outputValue 10
mrk&amp; 
</pre>
<p>The same could be done using pvput as follows:
</p>
<pre>
pvput -r "control" PVRsupportDouble control='{"limitLow":"-10","limitHigh":"10","minStep":".5"}'
</pre>

<h4>configScalarAlarm</h4>
<p>
An example usage is:
</p>
<pre>
mrk&amp; ./configScalarAlarm
recordName?
PVRsupportDouble
lowAlarmLimit
-8
lowWarningLimit
-6
highWarningLimit
6
highAlarmLimit
8
hysteresis
.1
Old : structure 
    scalarAlarm_t scalarAlarm
        double lowAlarmLimit -8
        double lowWarningLimit -6
        double highWarningLimit 6
        double highAlarmLimit 8
        double hysteresis 0.1
New : structure 
    scalarAlarm_t scalarAlarm
        double lowAlarmLimit -8
        double lowWarningLimit -6
        double highWarningLimit 6
        double highAlarmLimit 8
        double hysteresis 0.1
mrk&amp; 
</pre>
<p>
Just like configControl it can be invoked by giving all values as arguments.
</p>
<h4>configProcessRecord</h4>
<p>example usage is:
</p>
<pre>
mrk&amp; ./configProcessRecord
processRecordName
PVRprocessRecord
command?
remove
recordName?
PVRscalarDouble
// result is
PVRprocessRecord
argument={"command":"remove","recordName":"PVRsupportDouble"}
Old : structure 
    structure argument
        string command add
        string recordName PVRscalarDouble
    structure result
        string status success
New : structure 
    structure argument
        string command remove
        string recordName PVRscalarDouble
    structure result
        string status success
</pre>
<p>It can also be invoked with arguments.</p>
<p>
The following also works:
</p>
<pre>
pvput -r "argument,result" PVRprocessRecord argument='{"command":"add","recordName":"PVRscalarDouble"}'
Old : structure 
    structure argument
        string command add
        string recordName PVRscalarDouble
    structure result
        string status PVRscalarDouble already present
New : structure 
    structure argument
        string command add
        spwd
tring recordName PVRscalarDouble
    structure result
        string status PVRscalarDouble already present
</pre>
<h4>controlSigned</h4>
<p>
Convenience script for signed control limits.
</p>
<pre>
#!/bin/sh
./configControl PVRsupportDouble -10 10 .5
</pre>
<h4>controlUnsigned</h4>
<p>
Convenience script for unsigned control limits.
</p>
<pre>
#!/bin/sh
./configControl PVRsupportUByte 1 20 1
</pre>
<h4>scalarAlarmSigned</h4>
<p>
Convenience script for signed scalarAlarm limits.
</p>
<pre>
#!/bin/sh
./configScalarAlarm PVRsupportDouble -8 -6 6 8 .1
</pre>
<h4>scalarAlarmUnsigned</h4>
<p>
Convenience script for unsigned scalarAlarm limits.
</p>
<pre>
#!/bin/sh
./configScalarAlarm PVRsupportUByte 2 4 16 18 1
</pre>
<h4>configAll</h4>
<p>Use of this was shown above.</p>
<pre>
#!/bin/bash
./controlSigned
./scalarAlarmSigned
./controlUnsigned
./scalarAlarmUnsigned
./configProcessRecord PVRprocessRecord add PVRsupportDouble
./configProcessRecord PVRprocessRecord add PVRsupportUByte
./configProcessRecord PVRprocessRecord add PVRscalarDouble
./configProcessRecord PVRprocessRecord add PVRscalarUByte
</pre>

<h4>Support Examples</h4>
<p>Records PVRsupportDouble and PVRsupportUByte both use the <b>control</b>
and <b>scalarAlarm</b>
record support from pvDatabaseCPP.
</p>
<p>Previously there was an example accessing PVRsupportDouble.
Now lets look at an example accessing PVRsupportUByte.
</p>
<p>
After starting the database and running configAll, look at:
</p>
<pre>
pvget -r "control,scalarAlarm" PVRsupportUByte
PVRsupportUByte structure 
    control_t control
        double limitLow 1
        double limitHigh 20
        double minStep 1
        ubyte outputValue 0
    scalarAlarm_t scalarAlarm
        double lowAlarmLimit 2
        double lowWarningLimit 4
        double highWarningLimit 16
        double highAlarmLimit 18
        double hysteresis 1
</pre>
Look at the control and scalarAlarm settings.
<p>In one window:
</p>
<pre>
pvget -r "value,alarm,timeStamp,control.outputValue" -v -m PVRsupportUByte
</pre>
<p>Keep this window and see what happens when you run the following in another window:
</p>
<pre>
pvput PVRsupportUByte 40
</pre>
<p>In the first window you will see that <b>value</b> goes to 20 and the alarm changes.
It did NOT go to 40 because <b>control.limitHigh</b> is 20.
But <b>control.outputValue</b> changes by 1 each time the record processes.
On each process except the first only <b>timeStamp</b> and <b>control.outputValue</b>
change value.
This continues until <b>control.outputValue</b> is 20.
Then no more monitors occur.
</p>
<p>Now issue some more pvputs. For example to 19 then 15 then 5 then 0.
</p>
<h2>Plugin Examples</h2>

<h4>array</h4>
<p>The records PVRscalarArrayDouble, PVRscalarArrayUByte, PVRscalarArrayString, and PVRscalarArrayBoolean
are created in order to see the array plugin in action.
</p>
<pre>
pvput PVRdoubleArray value=[1,2,3,4,5,6,7,8,9,10]
...
</pre>
<br/>
then
<pre>
pvget -r "value[array=1:2:9]" PVRdoubleArray
PVRdoubleArray [2,4,6,8,10]
</pre>
then
<pre>
pvput -r "value[array=1:2:9]" PVRdoubleArray [100,200,300,400,500]
...
</pre>
then
<pre>
pvget -r value PVRdoubleArray
PVRdoubleArray [1,100,3,200,5,300,7,400,9,500]
</pre>
<p>
<b>NOTE:</b>
The syntax for setting value, i. e.</p>
<pre>
value='[10,20,30]'
</pre>
Also could be:
<pre>
value='["10","20","30"]'
</pre>
In fact if the element values are anything except an integer,
each element should be enclosed in quotes.
<h4>deadband and ignore</h4>
<p>In one window:</p>
<pre>
pvget -m -v -r "timeStamp[ignore=true],alarm[ignore=true],value[deadband=abs:1]" PVRdouble
</pre>
<p>Then in another window:</p>
<pre>
pvput PVRdouble 10
pvput PVRdouble 9.5
pvput PVRdouble 9
pvput PVRdouble 8.5
pvput PVRdouble 5
</pre>
</div>
</body>
</html>
