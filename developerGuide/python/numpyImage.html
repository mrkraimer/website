<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>numpyImage</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>numpyImage</h1>

<h2 class="nocount">2020.05.06</h2>
<dl>
  <dt>Author:</dt>
    <dd>Marty Kraimer</dd>
  <dt>WARNING</dt>
     <dd>
      This is a work in progress.
     </dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>


<div id="toc">

<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>
<p>This document describes a Python class that displays an image generated from a numpy array.
</p>
<p>The interface that a client sees is:
</p>
<pre>
class NumpyImage(QWidget) :
    def __init__(self,windowTitle,parent=None):
...
    def display(self,pixarray) :
...
</pre>
<p>This method creates an image from the <b>pixarray</b>.
The first call returns immediately.
Further calls will wait until the image for the previous call is complete.
It uses a <b>QThread</b> to synchronize with PyQt5 calls that generate the QImage.
</p>
<h2>NumpyImage Brief Overview</h2>
<p>While reading this section please look at the code: <b>testPython/numpyImage/numpyImage.py</b>
</p>
<p>
The code starts with:
</p>
<pre>
def toQImage(image):
...
</pre>
<p>
The arguments to this python function must be a numpy array.
It returns a QImage.
Currently it has the following limitations:
</p>
<ol>
  <li>Each element of the array must have dtype uint8 or int8</li>
  <li>The array must be either 2d or 3d.</li>
  <li>The data for the first two dimension should be a column,row array.
    Each column has the data for a row.
    The order for the columns is top to bottom, because this is what QImage expects.
    Note that method display, described below, flips the column order.
    Thus the client uses column order bottom to top.
  </li>
  <li>If 2d then the image will be a gray scale image.</li>
  <li>If 3d the shape of the third dimension must be 3 or 4.
      The third dimension is color.</li>
</ol> 

<p>The next code is:</p>
<pre>
class Worker(QThread):
...
</pre>
<p>
This code is required so that a new QImage will not be requested until the previous image
is displayed.
Without this code when <b>self.update()</b> is called, the PyQt5 code arranges for the
image to be generated by another thread and returns.
Thus an unlimited number of images may be in progress at the same time.
</p>
<p>
The code the client sees is:
</p>
<pre>
class NumpyImage(QWidget) :
...
    def display(self,pixarray) :
...
    def clientReleaseEvent(self,clientCallback) :
</pre>
where
<dl>
   <dt>display</dt>
     <dd>
     This is called by the client to display an image.
     Note that the first thing is does is wait until a possible previous image is displayed.
     </dd>
   <dt>clientReleaseEvent</dt>
     <dd>
      This is provided so that that client can select, via the mouse, a subimage from
       the image currently displayed.
     </dd>
</dl>


<h2>PyQt with PVAPY or P4P</h2>

<h3>Introduction</h3>
<p>
Both of the example Python applications use PyQt for the viewer windows.
The viewer is always started via:
</p>
<pre>
if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>
Each example has three types of python objects:
</p>
<ol>
   <li>The application itself</li>
   <li>PyQt5 code</li>
   <li>Server code, i.e. PVAPY or P4P</li>
</ol>

<h2>Threading rules for Python client working with PyQt5</h2>
<p>
The rules for accessing data are:
</p>
<ol>
   <li>Server data can only be manipulated via the server thread.</li>
   <li>PyQt5 data can only be manipulated via the QApplication thread</li>
   <li>The application data can be manipulated from either the server or QApplication thread</li>
</ol>

<p>The only serious compications is callbacks from a Server.
The client code must make sure that all PyQt5 objects are manipulated
via the QApplication thread.
Lets look at some of the code in 
</p>
<pre>
class PVAPYProvider(QObject) :
    monitorCallbacksignal = pyqtSignal()
    connectCallbacksignal = pyqtSignal()
    def __init__(self):
        QObject.__init__(self)
...
        self.init()
    def init(self) :
        self.connectCallbacksignal.connect(self.viewerconnectionCallback)
        self.monitorCallbacksignal.connect(self.viewermonitorCallback)
        self.callbackDoneEvent = Event()
        self.callbackDoneEvent.set()
        self.channel = Channel(getDynamicRecordName())
        self.channel.setConnectionCallback(self.pvapyconnectioncallback)

    def start(self) : 
...
        self.channel.monitor(self.pvapymonitorcallback,'field()')
...
    def viewerCallback(self,arg) :
        self.viewer.callback(arg)

    def pvapyconnectioncallback(self,arg) :
        if self.firstStart :
            self.isConnected = arg
            return
        data = dict()
        if arg==True :
            data["status"] = "connected"
        elif arg==False :
            data["status"] = "disconnected"
        else :
            data["exception"] = "bad pvapy connection callback =" + str(arg)
        self.connectdata = data
        self.callbackDoneEvent.clear()
        self.connectCallbacksignal.emit()

    def viewerconnectionCallback(self) :
        while self.connectdata is not None:
            try:
                arg = self.connectdata
                self.connectdata = None
                self.viewerCallback(arg)
            except Exception as error:
                arg["exception"] = repr(error)
                self.viewerCallback(arg)
        self.callbackDoneEvent.set()

    def pvapymonitorcallback(self,arg) :
        data = DynamicRecordData()
        data.name = arg['name']
        data.x = np.copy(arg['x'])
        data.y = np.copy(arg['y'])
        data.xmin = arg['xmin']
        data.xmax = arg['xmax']
        data.ymin = arg['ymin']
        data.ymax = arg['ymax']
        if not self.monitordata:
            self.monitordata = data
            self.callbackDoneEvent.clear()
            self.monitorCallbacksignal.emit()
        else:
            self.monitordata = data

    def viewermonitorCallback(self) :
        while self.monitordata is not None:
            try:
                arg = dict()
                arg['value'] = self.monitordata
                self.monitordata = None
                self.viewerCallback(arg)
            except Exception as error:
                arg["exception"] = repr(error)
                self.viewerCallback(arg)
        self.callbackDoneEvent.set()

if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>Lets first consider the connection callback.
In init the  client calls:
</p>
<pre>
self.connectCallbacksignal.connect(self.viewerconnectionCallback)
self.callbackDoneEvent = Event()
self.callbackDoneEvent.set()
self.channel = Channel(getDynamicRecordName())
self.channel.setConnectionCallback(self.pvapyconnectioncallback)
</pre>
<p>
Whenever the channel connection changes state pvapyconnectioncallback is called.
It executes the statements:
</p>
<pre>
self.connectdata = data
self.callbackDoneEvent.clear()
self.connectCallbacksignal.emit()
</pre>
<p>The last two statements causes viewerconnectionCallback
to be called via the QApplication thread.
viewerconnectionCallback calls:
</p>
<pre>
self.viewerCallback(arg)
</pre>
<p>
This is a call to a method in the PyQt viewer.
</p>

<p>The monitor callback code is similar but note the code.
</p>
<pre>
    def pvapymonitorcallback(self,arg) :
        data = DynamicRecordData()
        data.name = arg['name']
        data.x = np.copy(arg['x'])
        data.y = np.copy(arg['y'])
        data.xmin = arg['xmin']
        data.xmax = arg['xmax']
        data.ymin = arg['ymin']
        data.ymax = arg['ymax']
        if not self.monitordata:
            self.monitordata = data
            self.callbackDoneEvent.clear()
            self.monitorCallbacksignal.emit()
        else:
            self.monitordata = data
</pre>
<p>This code does not delay the callback thread while waiting for an image to be displayed.
Instead it makes sure that the data for the latest callback will be displayed,
but is willing to ignore monitor callbacks if it can not keep up.
</p>
<h2>Rapid Callbacks to a PyQt application</h2>
<p>If a PyQt application is receiving rapid callbacks that result
in updating widgets, the client might not see the widget update immediately.
Calling:
</p>
<pre>
QApplication.processEvents()
</pre>
Will causes the widgets changes to update immediately.


</div>
</body>
</html>
