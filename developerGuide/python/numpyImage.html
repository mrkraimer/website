<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>numpyImage</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>numpyImage</h1>

<h2 class="nocount">2020.06.03</h2>
<dl>
  <dt>Author:</dt>
    <dd>Marty Kraimer</dd>
  <dt>WARNING</dt>
     <dd>
      This is a work in progress.
     </dd>
</dl>

<p>This product is available via an
<a
href="../../LICENSE">open source license
</a>
</p>

</div>


<div id="toc">

<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>
<p>This document describes a Python class that displays an image generated from a numpy array.
</p>
<p>The interface that a client sees is:
</p>
<pre>
class NumpyImage(QWidget) :
    def __init__(self,windowTitle='no title',flipy=True):
...
    def display(self,pixarray,Format=str('') :
...
    def clientReleaseEvent(self,clientCallback) :
</pre>
where
<dl>
   <dt>__init__</dt>
     <dd>
     The client can provide a title for the displayed image
     and can ask for the order of y to be flipped.
     Note that a client is expected to have y increase from bottom to top,
     but QImage has height increase from top to bottom.
     </dd>
   <dt>display(self,pixarray,Format=str('')</dt>
     <dd>
     This is called by the client to display an image.
     The first call returns immediately.
    Further calls will wait until the previous image is displayed.
    It uses a <b>QThread</b> to synchronize with PyQt5 code that displays the QImage.
     </dd>
   <dt>clientReleaseEvent(self,clientCallback)</dt>
     <dd>
      This is provided so that that client can select, via the mouse, a subimage from
       the image currently displayed.
       When the mouse is pressed in the image, dragged to a new position,
       and then realesed, the client callback will be called.
     </dd>
</dl>
<h2>NumpyImage Brief Overview</h2>
<p>While reading this section please look at the code: <b>testPython/numpyImage/numpyImage.py</b>
</p>
<p>
The code starts with:
</p>
<pre>
class ImageToQImage() :
    def __init__(self):
...
    def toQImage(self,image,Format = str('')) :
</pre>
<dl>
  <dt>image</dt>
  <dd>
     <b>image</b> is an numpy array.
  </dd>
  <dt>Format</dt>
  <dd>
  Look for Format in
  <a
  href="https://doc.qt.io/qt-5/qimage.html">QImage
  </a>
  <br />
  An example is:
  <pre>
  Format=QImage::Format_ARGB32
  </pre>
  </dd>
</dl>
<p>
It returns a QImage.
Currently it has the following limitations:
</p>
<ol>
  <li>If Format is specified then any <b>QImage::Format_*</b> can be specified.
  The following only are used if Format is not specified.
  </li>
  <li>Each element of the array must have dtype uint8 or uint16.
  </li>
  <li>The array must be either 2d or 3d.</li>
  <li>The data for the first two dimension should be an (x,y) array.
    The order of the data must be:
    <pre>
    (0,0),(1,0),...(nx-1,0),
    (0,1),(1,1),...,(nx-1,1).
    ...
    (0,ny-1),(1,ny-1),...,(nx-1,ny-1)
    </pre>
    Thus x increases from left to right and y from bottom to top.
    <br />
    QImage orders columns from top to bottom.
    Method __init__, described above, by default flips the column order.
    If the client wants present (x,y) so that y increases from top to bottom it can change the default. 
  </li>
  <li>If 2d then the image will be a gray scale image.</li>
  <li>A 3d array is only supported for uint8. The shape of the third dimension must be 3 or 4.
      The third dimension is color and is either <b>QImage.Format_RGB888</b>
      or <b>QImage.Format_RGBA8888</b>
  </li>
</ol> 

<p>The next code is:</p>
<pre>
class Worker(QThread):
...
</pre>
<p>
This code is required so that a new QImage will not be requested until the previous image
is displayed.
When <b>self.update()</b> is called, the PyQt5 code arranges for the
image to be generated by another thread and returns.
Thus an unlimited number of images could be in progress at the same time.
The worker thread makes sure that only one image at a time is being generated.
</p>
<p>
The code the client sees is:
</p>
<pre>
class NumpyImage(QWidget) :
...
    def display(self,pixarray) :
...
    def clientReleaseEvent(self,clientCallback) :
...
</pre>

<h2>PyQt with PVAPY or P4P</h2>

<h3>Introduction</h3>
<p>
Both of the example Python applications use PyQt for the viewer windows.
The viewer is always started via:
</p>
<pre>
if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>
Each example has three types of python objects:
</p>
<ol>
   <li>The application itself</li>
   <li>PyQt5 code</li>
   <li>Server code, i.e. PVAPY or P4P</li>
</ol>

<h2>Threading rules for Python client working with PyQt5</h2>
<p>
The rules for accessing data are:
</p>
<ol>
   <li>Server data can only be manipulated via the server thread.</li>
   <li>PyQt5 data can only be manipulated via the QApplication thread</li>
   <li>The application data can be manipulated from either the server or QApplication thread</li>
</ol>

<p>The only serious compications is callbacks from a Server.
The client code must make sure that all PyQt5 objects are manipulated
via the QApplication thread.
Lets look at some of the code in 
</p>
<pre>
class PVAPYProvider(QObject) :
    monitorCallbacksignal = pyqtSignal()
    connectCallbacksignal = pyqtSignal()
    def __init__(self):
        QObject.__init__(self)
...
        self.init()
    def init(self) :
        self.connectCallbacksignal.connect(self.viewerconnectionCallback)
        self.monitorCallbacksignal.connect(self.viewermonitorCallback)
        self.callbackDoneEvent = Event()
        self.callbackDoneEvent.set()
        self.channel = Channel(getDynamicRecordName())
        self.channel.setConnectionCallback(self.pvapyconnectioncallback)

    def start(self) : 
...
        self.channel.monitor(self.pvapymonitorcallback,'field()')
...
    def viewerCallback(self,arg) :
        self.viewer.callback(arg)

    def pvapyconnectioncallback(self,arg) :
        if self.firstStart :
            self.isConnected = arg
            return
        data = dict()
        if arg==True :
            data["status"] = "connected"
        elif arg==False :
            data["status"] = "disconnected"
        else :
            data["exception"] = "bad pvapy connection callback =" + str(arg)
        self.connectdata = data
        self.callbackDoneEvent.clear()
        self.connectCallbacksignal.emit()

    def viewerconnectionCallback(self) :
        while self.connectdata is not None:
            try:
                arg = self.connectdata
                self.connectdata = None
                self.viewerCallback(arg)
            except Exception as error:
                arg["exception"] = repr(error)
                self.viewerCallback(arg)
        self.callbackDoneEvent.set()

    def pvapymonitorcallback(self,arg) :
        data = DynamicRecordData()
        data.name = arg['name']
        data.x = np.copy(arg['x'])
        data.y = np.copy(arg['y'])
        data.xmin = arg['xmin']
        data.xmax = arg['xmax']
        data.ymin = arg['ymin']
        data.ymax = arg['ymax']
        if not self.monitordata:
            self.monitordata = data
            self.callbackDoneEvent.clear()
            self.monitorCallbacksignal.emit()
        else:
            self.monitordata = data

    def viewermonitorCallback(self) :
        while self.monitordata is not None:
            try:
                arg = dict()
                arg['value'] = self.monitordata
                self.monitordata = None
                self.viewerCallback(arg)
            except Exception as error:
                arg["exception"] = repr(error)
                self.viewerCallback(arg)
        self.callbackDoneEvent.set()

if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>Lets first consider the connection callback.
In init the  client calls:
</p>
<pre>
self.connectCallbacksignal.connect(self.viewerconnectionCallback)
self.callbackDoneEvent = Event()
self.callbackDoneEvent.set()
self.channel = Channel(getDynamicRecordName())
self.channel.setConnectionCallback(self.pvapyconnectioncallback)
</pre>
<p>
Whenever the channel connection changes state pvapyconnectioncallback is called.
It executes the statements:
</p>
<pre>
self.connectdata = data
self.callbackDoneEvent.clear()
self.connectCallbacksignal.emit()
</pre>
<p>The last two statements causes viewerconnectionCallback
to be called via the QApplication thread.
viewerconnectionCallback calls:
</p>
<pre>
self.viewerCallback(arg)
</pre>
<p>
This is a call to a method in the PyQt viewer.
</p>

<p>The monitor callback code is similar but note the code.
</p>
<pre>
    def pvapymonitorcallback(self,arg) :
        data = DynamicRecordData()
        data.name = arg['name']
        data.x = np.copy(arg['x'])
        data.y = np.copy(arg['y'])
        data.xmin = arg['xmin']
        data.xmax = arg['xmax']
        data.ymin = arg['ymin']
        data.ymax = arg['ymax']
        if not self.monitordata:
            self.monitordata = data
            self.callbackDoneEvent.clear()
            self.monitorCallbacksignal.emit()
        else:
            self.monitordata = data
</pre>
<p>This code does not delay the callback thread while waiting for an image to be displayed.
Instead it makes sure that the data for the latest callback will be displayed,
but is willing to ignore monitor callbacks if it can not keep up.
</p>
<h2>Rapid Callbacks to a PyQt application</h2>
<p>If a PyQt application is receiving rapid callbacks that result
in updating widgets, the client might not see the widget update immediately.
Calling:
</p>
<pre>
QApplication.processEvents()
</pre>
Will causes the widgets changes to update immediately.


</div>
</body>
</html>
