<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>numpyImage</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>testPython/numpyImage</h1>

<h2 class="nocount">2020.07.02</h2>
<dl>
  <dt>Author:</dt>
    <dd>Marty Kraimer</dd>
  <dt>WARNING</dt>
     <dd>
      This is a work in progress.
     </dd>
</dl>

<p>This product is available via an
<a
href="../../LICENSE">open source license
</a>
</p>

</div>


<div id="toc">

<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>
<p>This document describes a Python class that displays an image generated from a numpy array.
It uses <b>PyQt5.QtGui.QImage</b> to display the image.
It is designed to support all the <b>Format</b> options of Qimage.
</p>
<p>
<b>NOTE:</b> testPython only tests a small subset of the Format options.
</p>
<p>
<b>QImage</b> documentation is available at:
<a
href="https://doc.qt.io/qt-5/qimage.html">QImage
</a>
</p>
<p>The interface that a client sees is:
</p>
<pre>
class NumpyImage(QWidget) :
    def __init__(self,windowTitle='no title',flipy=False,maxsize=800)
...
    def display(self,pixarray,Format=0,colorTable=None)
...
    def setZoomCallback(self,clientCallback,clientZoom=False)
...
    def resetZoom(self)
</pre>
where
<dl>
   <dt>__init__</dt>
     <dd>
     The client can 1) provide a title for the displayed image,
     2) can ask for the order of y to be flipped,
     and 3) can specify the maxsize ( for both height and width) of the displayed images.
     <br />
     <br />
     By default the caller has y increasing from top to bottom.
     which matches QImage.
     </dd>
   <dt>display(self,pixarray,Format=0,colorTable=None)</dt>
     <dd>
     This is called by the client to display an image.
     The client can optionally specify a Format and/or colorTable.
     <br />
    The first call returns immediately.
    Further calls will wait until the previous image is displayed.
    It uses a <b>QThread</b> to synchronize with PyQt5 code that displays the QImage.
    
     </dd>
   <dt>setZoomCallback(self,clientCallback,clientZoom=False)</dt>
     <dd>
      This is provided so that that client can select, via the mouse, a subimage from
       the image currently displayed.
       When the mouse is pressed in the image, dragged to a new position,
       and then released, the client callback will be called.
       If clientZoom is True then when the mouse is released, the client is called as follows:
<pre>
self.clientZoomCallback((xsize,ysize),(xmin,xmax,ymin,ymax))
</pre>
       and the client is responsible for determining
       if future calls to <b>display</b> display a zoomed image.
       <br />
       <br />
       If clientZoom is False then the client is called as follows:
<pre>
self.clientZoomCallback(xmin,xmax,ymin,ymax)
</pre>
      and future calls to <b>display</b> display the zoomed image.
     </dd>
     <dt>resetZoom</dt>
        <dd>Future calls to <b>display</b> display the full image.</dd>
</dl>
<h2>Brief Overview of NumpyImage</h2>
<p>While reading this section please look at the code: <b>testPython/numpyImage/numpyImage.py</b>
</p>
<p>
The code starts with:
</p>
<pre>
class ImageToQImage() :
    def __init__(self):
...
    def toQImage(self,image,Format=0,colorTable=None)) :
</pre>
<dl>
  <dt>image</dt>
  <dd>
     <b>image</b> is a numpy array.
  </dd>
  <dt>Format</dt>
  <dd>
  Look for Format in
  <a
  href="https://doc.qt.io/qt-5/qimage.html">QImage
  </a>
  <br />
  An example is:
<pre>
self.imageDisplay.display(image,Format=QImage.Format_Grayscale8)
</pre>
  </dd>
  <dt>colorTable</dt>
  <dd>
    If the client specifies a format that requires a colorTable then
    the client must also provide the colorTable.
    <br />
    An example is:
<pre>
color_table = [qRgb(i, i, i) for i in range(256)]
self.imageDisplay.display(image,\
    Format=QImage.Format_Indexed8,colorTable=self.rgbTable)
</pre>
  </dd>
</dl>
<p>
It returns a QImage.
Currently it has the following limitations:
</p>
<ol>
  <li>If Format is specified then any <b>QImage::Format_*</b> can be specified.
  <br />
  <br />
  The following are used if Format is not specified.
  </li>
  <li>Each element of the array must have dtype uint8 or uint16.
  </li>
  <li>The array must be either 2d or 3d.</li>
  <li>The data for the first two dimension should be an (x,y) array.
    The order of the data must be:
    <pre>
    (0,0),(1,0),...(nx-1,0),
    (0,1),(1,1),...,(nx-1,1).
    ...
    (0,ny-1),(1,ny-1),...,(nx-1,ny-1)
    </pre>
    Thus x increases from left to right and y from bottom to top.
    <br />
    QImage orders columns from top to bottom.
    Method __init__, described above, by default flips the column order.
    If the client wants present (x,y) so that y increases from top to bottom it can change the default. 
  </li>
  <li>If 2d then the image will be a gray scale image.</li>
  <li>A 3d array is only supported for uint8. The shape of the third dimension must be 3 or 4.
      The third dimension is color and is either <b>QImage.Format_RGB888</b>
      or <b>QImage.Format_RGBA8888</b>
  </li>
</ol> 

<p>The next code is:</p>
<pre>
class Worker(QThread):
...
</pre>
<p>
This code is required so that a new QImage will not be requested until the previous image
is displayed.
When <b>self.update()</b> is called, the PyQt5 code arranges for the
image to be generated by another thread and returns.
Thus an unlimited number of images could be in progress at the same time.
The worker thread makes sure that only one image at a time is being generated.
</p>
<h2>PyQt with PVAPY or P4P</h2>

<h3>Introduction</h3>
<p>
The example Python applications use PyQt for the viewer windows.
The viewer is always started via:
</p>
<pre>
if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>
Each example has three types of python objects:
</p>
<ol>
   <li>The application itself</li>
   <li>PyQt5 code</li>
   <li>Server code, i.e. PVAPY or P4P</li>
</ol>

<h2>Threading rules for Python client working with PyQt5</h2>
<p>
The rules for accessing data are:
</p>
<ol>
   <li>Server data can only be manipulated via the server thread.</li>
   <li>PyQt5 data can only be manipulated via the QApplication thread</li>
   <li>The application data can be manipulated from either the server or QApplication thread</li>
</ol>

<p>The only serious compications is callbacks from a Server.
The client code must make sure that all PyQt5 objects are manipulated
via the QApplication thread.
Lets look at some of the code in <b>testPython/qtimge/PVAPY_Qt_Viewer.py</b>.
</p>
<pre>
class PVAPYProvider(QObject) :
    monitorCallbacksignal = pyqtSignal()
    connectCallbacksignal = pyqtSignal()
    def __init__(self):
        QObject.__init__(self)
...
        self.connectCallbacksignal.connect(self.connectionCallback)
        self.monitorCallbacksignal.connect(self.monitorCallback)
        self.callbackDoneEvent = Event()
        self.callbackDoneEvent.clear()

    def start(self) : 
        if self.firstStart :
             self.channel = Channel(self.channelName)
             self.firstStart = False
             self.channel.setConnectionCallback(self.pvapyconnectioncallback)
        self.channel.monitor(self.pvapymonitorcallback\
...

    def viewerCallback(self,arg) :
        self.viewer.callback(arg)

    def pvapyconnectioncallback(self,arg) :
        ...
        self.connectCallbacksignal.emit()
        self.callbackDoneEvent.wait()
        self.callbackDoneEvent.clear()

    def connectionCallback(self) :
        ...
        self.callbackDoneEvent.set()
        ...

    def pvapymonitorcallback(self,arg) :
       ...
           self.monitorCallbacksignal.emit()
           self.callbackDoneEvent.wait()
           self.callbackDoneEvent.clear()

    def monitorCallback(self) :
        ...
        self.callbackDoneEvent.set()

if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>Lets first consider the connection callback.
In init the  client calls:
</p>
<pre>
self.connectCallbacksignal.connect(self.connectionCallback)
self.callbackDoneEvent = Event()
self.callbackDoneEvent.set()
</pre>
<p>
Whenever the channel connection changes state pvapyconnectioncallback is called.
It executes the statements:
</p>
<pre>
...
self.connectCallbacksignal.emit()
self.callbackDoneEvent.wait()
self.callbackDoneEvent.clear()
</pre>
<p>The emit causes connectionCallback
to be called via the QApplication thread.
When connectionCallback executes:
</p>
<pre>
self.callbackDoneEvent.set()
</pre>
The wait statement retuns

<p>The monitor callback code is similar but note the code.
</p>
<pre>
    def pvapymonitorcallback(self,arg) :
        if self.monitordata==None:
            data = {\
                "format" : arg['argument.format'],\
                "height": arg['argument.height'],\
                "width": arg['argument.width'],\
                "value": arg['result.value']\
            }
            self.monitordata = data
            self.monitorCallbacksignal.emit()
            self.callbackDoneEvent.wait()
            self.callbackDoneEvent.clear()
        else:
            self.monitordata = data
</pre>
<p>This code delays the callback thread while waiting for an image to be displayed.
</p>
<p>
<b>Question</b> Should the wait statement be removed?
</p>
<h2>Rapid Callbacks to a PyQt application</h2>
<p>If a PyQt application is receiving rapid callbacks that result
in updating widgets, the client might not see the widget update immediately.
Calling:
</p>
<pre>
QApplication.processEvents()
</pre>
Will causes the widgets changes to update immediately.


</div>
</body>
</html>
