<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>Python with PVRecords</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>Python with PVRecords</h1>
<h2 class="nocount">2020.05.05</h2>
<dl>
  <dt>Author:</dt>
    <dd>Marty Kraimer</dd>
  <dt>Contributors</dt>
     <dd>Sinisa Veseli
       <br /> provided help with pvapy.
       He also added support for connection changes.
     </dd>
  <dt>WARNING</dt>
     <dd>
      This is a work in progress.
     </dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>

<div id="toc">

<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>

<div id="contents" class="contents">

<h2>Introduction</h2>

<p>
This describes two Python examples that use pvDatabase records. 
</p>
<p>
The first is:
<a
href="mandelbrot.html">mandelbrot
</a>
</p>
<p>
The second is:
<a
href="plot2dcurve.html">plot2dcurve
</a>
</p>
<p>
Each example uses:
<a
href="numpyImage.html">numpyImage
</a>
</p>
<p>
The database used by the examples is also described:
<a
href="database.html">database
</a>
</p>


<h2>Installation</h2>

<h3>Python</h3>
<p>Python3 is required as well as using pip to install the following:</p>
<pre>
numpy
PyQt5
PyQt5-sip
QtPy
p4p
pvapy
pyqtgraph
</pre>

<h3>EPICS7</h3>
<p>An EPICS7 release is required.
See:
<a href="https://epics.anl.gov/download/base/index.php">EPICS7</a>
</p>

<h3>testPython</h3>
<p>After EPICS7 has been built then in any directory you choose execute the following</p>
<pre>
git clone https://github.com/mrkraimer/testPython.git
cd testPython/database
cp  ExampleRELEASE.local RELEASE.local
EDIT RELEASE.local SEE BELOW
make
cd iocBoot/mandelbrotDatabase
../../bin/linux-x86_64/mandelbrotDatabase st.cmd 
</pre>
<p>You are now ready to run the examples</p>
<p><b>RELEASE.local</b> must be changed so that 
the definition of <b>EPICS7_DIR</b> is the location where You built EPICS7.
</p>

<h2>PyQt with PVAPY or P4P</h2>

<h3>Introduction</h3>

<p>
Both of the example Python applications use PyQt for the viewer windows.
The viewer is always started via:
</p>
<pre>
if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>
Each example has three types of python objects:
</p>
<ol>
   <li>The application itself</li>
   <li>PyQt5 code</li>
   <li>Server code, i.e. PVAPY or P4P</li>
</ol>

<h2>Threading rules for Python client working with PyQt5</h2>
<p>
The rules for accessing data are:
</p>
<ol>
   <li>Server data can only be manipulated via the server thread.</li>
   <li>PyQt5 data can only be manipulated via the QApplication thread</li>
   <li>The application data can be manipulated from either the server or QApplication thread</li>
</ol>

<p>The only serious compications is callbacks from a Server.
The client code must make sure that all PyQt5 onjects are manipulated
via the QApplication thread.
Lets look at some of the code in 
</p>
<pre>
class PVAPYProvider(QObject) :
    monitorCallbacksignal = pyqtSignal()
    connectCallbacksignal = pyqtSignal()
    def __init__(self):
        QObject.__init__(self)
...
        self.init()
    def init(self) :
        self.connectCallbacksignal.connect(self.viewerconnectionCallback)
        self.monitorCallbacksignal.connect(self.viewermonitorCallback)
        self.callbackDoneEvent = Event()
        self.callbackDoneEvent.set()
        self.channel = Channel(getDynamicRecordName())
        self.channel.setConnectionCallback(self.pvapyconnectioncallback)

    def start(self) : 
...
        self.channel.monitor(self.pvapymonitorcallback,'field()')
...
    def viewerCallback(self,arg) :
        self.viewer.callback(arg)

    def pvapyconnectioncallback(self,arg) :
        if self.firstStart :
            self.isConnected = arg
            return
        data = dict()
        if arg==True :
            data["status"] = "connected"
        elif arg==False :
            data["status"] = "disconnected"
        else :
            data["exception"] = "bad pvapy connection callback =" + str(arg)
        self.connectdata = data
        self.callbackDoneEvent.clear()
        self.connectCallbacksignal.emit()

    def viewerconnectionCallback(self) :
        while self.connectdata is not None:
            try:
                arg = self.connectdata
                self.connectdata = None
                self.viewerCallback(arg)
            except Exception as error:
                arg["exception"] = repr(error)
                self.viewerCallback(arg)
        self.callbackDoneEvent.set()

    def pvapymonitorcallback(self,arg) :
        data = DynamicRecordData()
        data.name = arg['name']
        data.x = np.copy(arg['x'])
        data.y = np.copy(arg['y'])
        data.xmin = arg['xmin']
        data.xmax = arg['xmax']
        data.ymin = arg['ymin']
        data.ymax = arg['ymax']
        if not self.monitordata:
            self.monitordata = data
            self.callbackDoneEvent.clear()
            self.monitorCallbacksignal.emit()
        else:
            self.monitordata = data

    def viewermonitorCallback(self) :
        while self.monitordata is not None:
            try:
                arg = dict()
                arg['value'] = self.monitordata
                self.monitordata = None
                self.viewerCallback(arg)
            except Exception as error:
                arg["exception"] = repr(error)
                self.viewerCallback(arg)
        self.callbackDoneEvent.set()

if __name__ == '__main__':
    app = QApplication(list())
</pre>
<p>Lets first consider the connection callback.
In init the  client calls:
</p>
<pre>
self.connectCallbacksignal.connect(self.viewerconnectionCallback)
self.callbackDoneEvent = Event()
self.callbackDoneEvent.set()
self.channel = Channel(getDynamicRecordName())
self.channel.setConnectionCallback(self.pvapyconnectioncallback)
</pre>
<p>
Whenever the channel connection changes state pvapyconnectioncallback is called.
It executes the statements:
</p>
<pre>
self.connectdata = data
self.callbackDoneEvent.clear()
self.connectCallbacksignal.emit()
</pre>
<p>The last two statements causes viewerconnectionCallback
to be called via the QApplication thread.
viewerconnectionCallback calls:
</p>
<pre>
self.viewerCallback(arg)
</pre>
<p>
This is a call to a method in the PyQt viewer.
</p>

<p>The monitor callback code is similar but note the code.
</p>
<pre>
    def pvapymonitorcallback(self,arg) :
        data = DynamicRecordData()
        data.name = arg['name']
        data.x = np.copy(arg['x'])
        data.y = np.copy(arg['y'])
        data.xmin = arg['xmin']
        data.xmax = arg['xmax']
        data.ymin = arg['ymin']
        data.ymax = arg['ymax']
        if not self.monitordata:
            self.monitordata = data
            self.callbackDoneEvent.clear()
            self.monitorCallbacksignal.emit()
        else:
            self.monitordata = data
</pre>
<p>This code does not delay the callback thread while waiting for an image to be displayed.
Instead it makes sure that the data for the latest callback will be displayed,
but is willing to ignore monitor callbacks if it can not keep up.
</p>
<h2>Rapid Callbacks to a PyQt application</h2>
<p>If a PyQt application is receiving rapid callbacks that result
in updating widgets, the client might not see the widget update immediately.
Calling:
</p>
<pre>
QApplication.processEvents()
</pre>
Will causes the widgets changes to update immediately.

</div>
</body>
</html>
