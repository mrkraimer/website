<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>testPython/PY_NTNDA_Viewer</title>
  <link rel="stylesheet" type="text/css"
  href="../../css/base.css" />
  <link rel="stylesheet" type="text/css"
  href="../../css/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="../../css/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>testPython/PY_NTNDA_Viewer</h1>

<h2 class="nocount">2020.06.23</h2>
<dl>
  <dt>Author:</dt>
    <dd>Marty Kraimer</dd>
  <dt>WARNING</dt>
     <dd>
      This is a work in progress
     </dd>
</dl>

<p>This product is available via an <a
href="../../LICENSE">open source license
</a></p>

</div>


<div id="toc">

<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>
<p>
This document briefly discusses:
1) ADViewers/NTNDA_Viewer, a Python Image viewer that comes
with areaDetector/ADViewers.
2) testPython/NTNDA_Viewer, another implementation,
3) ImageJ and
4) QImage
</p>
<p>See
<a href="index.html">index</a>
for installation instructions.
</p>
<p>The version that comes with areaDetector is
<a href="https://github.com/areaDetector/ADViewers/tree/master/Python/PY_NTNDA_Viewer">PVAPY_NTNDA_Viewer</a>
with documentation at:
<a href="https://areadetector.github.io/master/ADViewers/PY_NTNDA_Viewer.html">PVAPY_NTNDA_Viewer.html</a>
</p>
<p>
After starting ADSimDetector, as described in the previous link, you are ready the run the example,
which is located in directory <b>testPython/PY_NTNDA_Viewer</b>
</p>
<p>Run the following:
</p>
<pre>
python PVAPY_NTNDA_Viewer.py &amp;
</pre> 
<h2>ADViewers/NTNDA_Viewer</h2>
<p>
ADViewer uses <b>pyqtgraph.widgets.RawImageWidget</b>
</p>
<p>The following code is used to display an image</p>
<pre>
class Image_Display(RawImageWidget,QWidget) :
    def __init__(self,parent=None, **kargs):
        RawImageWidget.__init__(self, parent=parent,scaled=True)
 """ THIS COMMENT IS FROM RawImageWidget
        Setting scaled=True will cause the entire image to be displayed within the boundaries of the widget.
        This also greatly reduces the speed at which it will draw frames.
"""
...
    def display(self,image,pixelLevels) :
        self.setImage(image,levels=pixelLevels)
"" THIS COMMENT IS FROM RawImageWidget
        img must be ndarray of shape (x,y), (x,y,3), or (x,y,4).
        Extra arguments are sent to functions.makeARGB
"""
...
</pre>
<p>setImage is a method in RawImage Widget that creates a pixarray that can be used to create a QImage.
Some notes:
</p>
<dl>
   <dt>scaled=True</dt>
   <dd>
   This results in a Python loop accessing the entire pixel array.
   For example (nx,ny,nz)=(800,800,3) means 1,920,000 elements
   </dd>
   <dt>levels=pixelLevels</dt>
   <dd>
   This also results in a Python loop accessing the entire pixel array.
   </dd>
   <dt>image dtype</dt>
   <dd>
   numpy is used to convert the image to a numpy array with dtype uint8.
   Since this is done by numpy it is far more efficent than using a python for loop.
   But no matter what type the original image has, it is converted to an image with uint8 pixels.
   </dd>
   <dt>Threads</dt>
   <dd>
   <b>setImage</b> is called via the QApplication thread.
   The actual image is generated in another thread and by C/C++ code.
   Thus there could potentially be multiple images being generated simultaneously.
   But the two python loops result in the images almost always being generated faster
   than Python can ask for new images.
   </dd>
</dl>

<h2>testPython/NTNDA_Viewer</h2>
<p>
ADViewer uses 
<a href="numpyImage.html">numpyImage</a>
Some Notes:
</p>
<dl>
   <dt>performance</dt>
   <dd>
   There are no Python loops accessing the entire pixel array.
   </dd>
   <dt>pixelLevels</dt>
   <dd>
   This is not supported.
   </dd>
   <dt>image dtype</dt>
   <dd>
   If the image dtype is unit8 the image is not modified.
   If the dtype is uint16 and Color mode is mono the image is not modified.
   In all other cases numpy converts the image array to have dtype uint8.
   </dd>
   <dt>Threads</dt>
   <dd>
   The first request to display an image is done without waiting.
   Further requests wait until the image for the previous request has been displayed. 
   </dd>
</dl>
<h2>ADViewers/ImageJ/EPICS_areaDetector</h2>
<p>For monchrome images the following is done:
</p>
<dl>
   <dt>uint8</dt>
   <dd>
       ij.process.ByteProcessor is used.
   </dd>
   <dt>unit16</dt>
   <dd>
       ij.process.ShortProcessor is used.
   </dd>
   <dt>all other types</dt>
   <dd>
       ij.process.FloatProcessor is used.
   </dd>
</dl>
<p>For color images ij.process.ColorProcessor is used.
</p>
<h2>ImageJ</h2>
<p>
<a href="https://imagej.nih.gov/ij/docs/guide/146.html">ImageJ</a>
states that ImageJ can handle the following:
</p>
<pre>
8-bit Images that can display 256 gray levels (integers only).
16-bit Images that can display 65536 gray levels (integers only).
32-bit Images that can display 4294967296 gray levels (real numbers).
    In 32-bit images, pixels are described by floating point values and can have any intensity value.
RGB Color Color Images that can display 256 values in the Red, Green and Blue channel.
  These are 24-bit color images.
  RGB color images can also be 32-bit color images (24-bit color images with additional eight bits coding alpha blending values,
  i.e., transparency).
</pre>
<h2>QImage</h2>
<p>
<a href="https://doc.qt.io/qt-5/qimage.html">QImage</a>
states the following:
</p>
<div class="table"><table class="valuelist"><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QImage::Format_Invalid</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The image is invalid.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_Mono</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_MonoLSB</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">The image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_Indexed8</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">The image is stored using 8-bit indexes into a colormap.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB32</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">The image is stored using a 32-bit RGB format (0xffRRGGBB).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_ARGB32</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">The image is stored using a 32-bit ARGB format (0xAARRGGBB).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_ARGB32_Premultiplied</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">The image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB16</code></td><td class="topAlign tblval"><code>7</code></td><td class="topAlign">The image is stored using a 16-bit RGB format (5-6-5).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_ARGB8565_Premultiplied</code></td><td class="topAlign tblval"><code>8</code></td><td class="topAlign">The image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB666</code></td><td class="topAlign tblval"><code>9</code></td><td class="topAlign">The image is stored using a 24-bit RGB format (6-6-6). The unused most significant bits is always zero.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_ARGB6666_Premultiplied</code></td><td class="topAlign tblval"><code>10</code></td><td class="topAlign">The image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB555</code></td><td class="topAlign tblval"><code>11</code></td><td class="topAlign">The image is stored using a 16-bit RGB format (5-5-5). The unused most significant bit is always zero.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_ARGB8555_Premultiplied</code></td><td class="topAlign tblval"><code>12</code></td><td class="topAlign">The image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB888</code></td><td class="topAlign tblval"><code>13</code></td><td class="topAlign">The image is stored using a 24-bit RGB format (8-8-8).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB444</code></td><td class="topAlign tblval"><code>14</code></td><td class="topAlign">The image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.</td></tr>
<tr><td class="topAlign"><code>QImage::Format_ARGB4444_Premultiplied</code></td><td class="topAlign tblval"><code>15</code></td><td class="topAlign">The image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGBX8888</code></td><td class="topAlign tblval"><code>16</code></td><td class="topAlign">The image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is the same as the Format_RGBA8888 except alpha must always be 255. (added in Qt 5.2)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGBA8888</code></td><td class="topAlign tblval"><code>17</code></td><td class="topAlign">The image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32 this is a byte-ordered format, which means the 32bit encoding differs between big endian and little endian architectures, being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA. (added in Qt 5.2)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGBA8888_Premultiplied</code></td><td class="topAlign tblval"><code>18</code></td><td class="topAlign">The image is stored using a premultiplied 32-bit byte-ordered RGBA format (8-8-8-8). (added in Qt 5.2)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_BGR30</code></td><td class="topAlign tblval"><code>19</code></td><td class="topAlign">The image is stored using a 32-bit BGR format (x-10-10-10). (added in Qt 5.4)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_A2BGR30_Premultiplied</code></td><td class="topAlign tblval"><code>20</code></td><td class="topAlign">The image is stored using a 32-bit premultiplied ABGR format (2-10-10-10). (added in Qt 5.4)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGB30</code></td><td class="topAlign tblval"><code>21</code></td><td class="topAlign">The image is stored using a 32-bit RGB format (x-10-10-10). (added in Qt 5.4)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_A2RGB30_Premultiplied</code></td><td class="topAlign tblval"><code>22</code></td><td class="topAlign">The image is stored using a 32-bit premultiplied ARGB format (2-10-10-10). (added in Qt 5.4)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_Alpha8</code></td><td class="topAlign tblval"><code>23</code></td><td class="topAlign">The image is stored using an 8-bit alpha only format. (added in Qt 5.5)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_Grayscale8</code></td><td class="topAlign tblval"><code>24</code></td><td class="topAlign">The image is stored using an 8-bit grayscale format. (added in Qt 5.5)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_Grayscale16</code></td><td class="topAlign tblval"><code>28</code></td><td class="topAlign">The image is stored using an 16-bit grayscale format. (added in Qt 5.13)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGBX64</code></td><td class="topAlign tblval"><code>25</code></td><td class="topAlign">The image is stored using a 64-bit halfword-ordered RGB(x) format (16-16-16-16). This is the same as the Format_RGBA64 except alpha must always be 65535. (added in Qt 5.12)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGBA64</code></td><td class="topAlign tblval"><code>26</code></td><td class="topAlign">The image is stored using a 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_RGBA64_Premultiplied</code></td><td class="topAlign tblval"><code>27</code></td><td class="topAlign">The image is stored using a premultiplied 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</td></tr>
<tr><td class="topAlign"><code>QImage::Format_BGR888</code></td><td class="topAlign tblval"><code>29</code></td><td class="topAlign">The image is stored using a 24-bit BGR format. (added in Qt 5.14)</td></tr>
</table></div>
<h2>Some Comments</h2>
<h3>ImageJ vs QImage</h3>
<p>They appear to have a lot of similaity in the types of images they support.
They also have similar codec support.
</p>
<h3>ADSimDetector</h3>
<p>This has data types for signed and unsigned integers of length 8, 16, 32, and 64.
It also has data types float and double.
</p>
<p>
When simulation mode is LinearRamp and gain is 1.0,
testPython/PY_NTNDA_Viewer appears to work well with all data types. 
</p>
<p>
When simulation mode is peaks the gain must be set to 255 for int8 and uint8,
65535 for int16 and uint16, and who knows what for other datatypes.
I think this is a problem with similation mode peaks.
</p>
<p>ADViewers/PY_NTNDA_Viewer works well only for int8 and uint8.
</p>
<h3>Question</h3>
<p>Can PY_NTNDA_Viewer take advantage of more features of QImage?
</p>
<p>
Can the ImageJ viewer take advantage of more features of ImageJ?
</p>
</div>
</body>
</html>
